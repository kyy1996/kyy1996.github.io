<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在阅文的实习生活]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%9C%A8%E9%98%85%E6%96%87%E7%9A%84%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%B4%BB.html</url>
    <content type="text"><![CDATA[引言我于2018年6月来到阅文集团实习，担任后端开发。主要从事的工作内容有基于Java的程序开发与基于PHP的网站开发以及相关的技术调研工作。直到2018年12月，在企业导师的带领下我已经完成了内容管理系统后端接口开发、小程序接口开发以及部分活动的接口开发，在公司内向同事们做过自己的技术分享。从这些任务中也逐渐学会与适应了企业中的工作流程以及实战开发，巩固了原有的知识，淘汰了陈旧的技术，学到了高性能的项目体系。实习的工作对我来说是非常宝贵的提升自我的机会。在实战中，我们会遇到一些在课堂中被忽略的问题。比较经典的有用户登录态的传递、前端与后端的数据类型不符的问题、提高后端接口性能、系统的自动化运维问题、平台的容错容灾能力提升问题等。这些问题在小流量时不会那么突出，但是当访问量暴涨时将产生灾难性故障。因此，在实际开发中，如何解决这些问题也成为了我们程序员的必备知识。接下来将谈谈我们在实战中的应用方案以及想法。平台体系与通用开发流程在实战的开发中，往往开发被分为了前端、RN（ReactNative）、API以及各项支撑服务。这也是现在比较流行的微服务架构，我自己在研究基于微服务架构体系的腾讯Tars开源项目。这种架构的好处就是让各端的开发同学能够专注于自己所开发的服务工作而不用关心其他内容，使得业务能够被较快地交付。当然，在正式开发之前，我们需要有一个完整的业务开发流程。在课堂中练习与自学时，往往只有自己一个人。这时我自己其实担任了四个角色：产品经理、开发、运维以及测试。由于精力有限，所以往往开发出的产品只能自己一个人自娱自乐。在公司中，这四个角色被分配给了多个同学，每个同学专注于自己的工作即可。这时的开发流程变为了：需求调研-&gt;需求评审-&gt;技术预研-&gt;实际开发-&gt;项目测试-&gt;上线。看似流程变多变繁琐了，但是这样的流程能够让项目的进展变得规范又敏捷，每个人只要跟着规范走即可快速完成项目的迭代任务。端与后台规范由于在开发期间需要有端（IOS、安卓、RN、H5）与后台（API）进行通信，当然，后台（API）与服务（微服务）也需要进行通信，因此在正式开发之前需要各方商量讨论出一套标准的接口格式规范（也可以认为是通信协议），这样可以让大家在约定好通信协议后，各自按照通信协议开发即可。也就是说，只要在开发期间各方保证自己的接口能够提供协议中的服务即可。这样能够在各方任务完成，开始联调时缩短所需时间，减轻各自的任务。这里，我们使用的一套接口管理平台是YAPI，它能够实现在线编辑接口，生成模拟数据服务器，执行单元测试以及在线运行接口的功能。而接口与服务之间的通信协议则通过独立的规范文件给出。通过该规范文件能够自动生成各类语言的接口代码，我们只需要将接口实现，即可在程序中使用。常见问题用户登录态的传递由于后台接口都是“无状态”的，因此需要在登录后返回给客户端一个token，然后客户端将token传递给后台来实现登录态的维持。这种情况下，我们可以将token放置在Cookies中，然后在客户端每次请求时传给后台。这里，由于用户登录系统后，后台需要每次请求时校验客户端传入的token是否有效，在流量大时，这可能会成为接口的潜在性能瓶颈。因此我们的做法是将校验与登录分为两个独立的微服务，客户端从统一登录服务获取token，后台通过校验服务实现验证。这种结构满足了日均万级的访问需求。前端与后端的数据类型不符的问题在开发时，虽然通过各自遵守“协议”来进行开发，但是由于语言、框架的差异，会导致数据溢出的问题。比如在Java中整数大致分为长整型、整型，但是传递给前端后，前端使用的JavaScript语言中没有长整型，这就导致了数值的溢出。因此，我们的解决方案是将数值在传递时转换成字符串型来规避溢出的问题。后台在项目上线后，由于经过了测试，通常是不会出现重大问题的。但是当访问流量增大之后，到后台的请求数量会暴增，这就导致了后台接口的性能将成为潜在的瓶颈。这个我们可以通过压力测试来测出后台接口的瓶颈范围，也就是QPS（Query Per Second）。我们项目也在凌晨发生过流量暴增导致服务宕机的事件，根本原因就是在上线前没有对接口进行压力测试，代码部署完成后，监控出现的异常波动也未引起重视，从而导致了之后宕机的问题。因此尽可能提高接口性能也成为了我们后台开发的必备能力之一。网络IO现代计算机的CPU运算能力一向不是瓶颈的来源，IO才是。在网络服务中，通信IO成为了木桶中的短板。但是由于微服务的架构就是，每个基础服务将在体系中独立成为一个网络服务，接口层通过内网访问的形式与服务交换数据、发起请求，因此无法规避网络问题。那我们的解决办法就是在微服务中提供批量接口。接口层先行处理生成需要提交给微服务的数据集合，通过一次请求就能完成数据的处理。在数据量多的情况下，这种优化将大幅提升系统的性能。存储IO另外，除了网络IO短板之外，存储IO也会成为短板。比较常见的如数据库系统。我曾经在运营自己的网站时，在一个页面中对数据库中百万级的数据进行求和，这个操作使得单页的QPS锐减至1以下，一次请求需要花费2-3s才能完成。因此对数据库的优化就显得尤为重要了。我们通常的对策是：对数据库进行索引优化。充分利用索引表查询快的特点来缓解这个问题。我后来对页面需要访问的数据库进行了建立索引，优化查询语句等操作，使得QPS回增至20左右。在进行工作中的服务开发时，也需要对数据库进行索引优化，同时大家一起开会评审数据表结构，对查询语句进行优化。但是，数据库操作一般是由微服务进行的，请求往往都是直接到达接口层。这也就意味着接口层也有很大的优化空间。比如使用内存数据库Redis来缓存微服务的返回数据，以此来提升性能。当然，Redis也提供了批量接口供我们使用。Redis能承受最高的QPS大约在百万级别，每次查询时间在毫秒级别，对于常见的业务来说足够使用了。运维系统的自动化运维问题由于在实战中，平台上可能有成百上千个服务在运行，但是运维人力有限，不能保证快速根据业务量调整服务能够使用的资源大小，因此一套具备自动化运维的系统就成为实战中的必需品了。这里我们可以借鉴了Docker容器的思想，即将服务本体程序与依赖包一起打包为一个可直接交付部署的容器，我们只需要花费极少的成本即可将服务整体迁移或复制到新的机器上。我们基于Docker容器，另外开发了监控平台、统一配置管理等子系统，组合成了一套微服务治理系统，实现了服务的自动扩容、缩容。结合OA系统，制定了服务的发布规范，使得系统运行更加稳定。平台的容错容灾能力提升问题但是，尽管我们做了那么多优化，服务还是有可能被不可抗力影响。因此，分布式的系统管理与数据热备份也成为了服务治理平台的功能之一。我们将用户的流量统一引导至反向代理服务器（nginx）下，在各个地域的服务器中保存页面与数据的缓存。首先将服务器的地址由平台分发至nginx中，当某一台服务器节点中断时，nginx可快速检测到并同时降低节点权重，用户的请求也会被分发至其他可用节点中处理。这保证了在极端情况下服务的可用性。总结我在阅文实习所学到的内容大致被我整理成了本篇报告。接下来将要开始做毕业设计，我会将这些宝贵的工作经验进行整理归纳，尝试提高自己的基础能力。薄弱的环节也将逐渐得到提升，成为理想中不断成长的程序员。]]></content>
      <categories>
        <category>谈生活</category>
      </categories>
      <tags>
        <tag>阅文集团</tag>
        <tag>实习</tag>
        <tag>毕业</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac下搭建PHP网站运行环境]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%9C%A8Mac%E4%B8%8B%E6%90%AD%E5%BB%BAPHP%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[MacOS基础扫盲什么是 macOSMacOS 是 苹果 公司专门为 Macintosh 苹果计算机开发的一款基于 FreeBSD 系统的 类Unix 操作系统，使用的内核为苹果公司自己研发的 Darwin。相比传统的 Linux 与 类Unix 系统，macOS 具有更美观与操作便捷的界面，同时也具备高效的命令行操作方式。与 Windows 的对比Windows 系统可以运行在 Mac 电脑上，而 macOS 却不能直接安装在 Windows PC 上（但可以安装黑苹果，具体方式请自行百度）。Windows 的软件不能在 macOS 上运行，反之亦然，macOS 的软件不能在 Windows 上运行。在 macOS 上可以开发编译运行于 macOS、Linux（或 Unix） 与 Windows 程序（可通过 虚拟机 直接安装），但是 Windows 上不能轻易地开发 macOS 程序（需要繁琐地通过虚拟机或黑苹果并下载安装第三方 kext 驱动和引导程序来安装）。类Unix系统 意味着什么目前大部分的服务器运行的系统都是 Linux 或者 Unix，类Unix 系统能够提供与前两者相似的操作与开发流程。为 类Unix 编写的程序也能很方便地移植到 Linux 中。系统目录结构和配置文件与 Linux 系统相似，甚至能直接复制使用。能够拥抱各类开源的世界严格区分大小写的文件系统能够迫使程序员编写出更健壮的程序。但是macOS 所使用的 APFS 或 HFS+ 文件系统默认是不区分大小写的。MacOS 中的终端启动终端按下Command ⌘ + 空格打开 Spotlight 聚焦搜索，或打开 Launchpad启动台，输入terminal并按下回车 ↩︎。 之后会显示一个白色窗口，其中已经有了一些黑色文字，这个窗口就是我们的终端。我们可以在其中输入大部分的 Linux 命令，例如：ls 列出文件夹目录，touch 创建一个文件，rm 删除文件。注意：输入命令后，需要按下回车 ↩︎才能执行命令。下文中所称的“运行”均是指输入命令并按下回车 ↩︎新建一个终端标签页或窗口有时候我们希望在一个终端运行程序时，能运行第二个程序，我们可以新打开一个终端窗口。通常，我个人习惯是在终端中新建一个标签页，当然，也可以新建一个窗口，快捷键分别为Command ⌘+T和Command ⌘+N。 安装 Homebrew 包管理器什么是包管理器包管理器能够用来统一管理系统中安装的各类软件包（二进制文件/程序或文本文件），维护各个软件包之间的相互依赖关系。包管理器会在安装或更新软件时自动检查依赖关系并自动安装所缺少的软件包，省去用户手工安装的麻烦事。Homebrew 是什么在 Linux 系统中有现成成熟的包管理系统，例如 Ubuntu 中的 APT 与 CentOS 中的 YUM。而 macOS 中，没有预装，官方也没有，一套成熟的包管理系统。而 Homebrew 就是一套运行于 macOS 上的包管理系统。Homebrew 官方网站：Homebrew如何安装 Homebrew启动一个终端，在其中复制如下命令1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"按下回车 ↩︎运行。等待一会儿，出现如图所示的提示，意思是按下回车 ↩︎继续或按其他键取消安装。我们按下回车 ↩︎。到这一步，安装程序需要以管理员身份继续运行。输入你的登录密码，并按回车 ↩︎继续。注意：在 终端 中输入密码，是不会回显任何提示的，包括*符号也不会出现。所以只管放心大胆地输入你的登录密码即可。输入错了怎么办？疯狂地按下退格键 ⌫再重新输入你的登录密码吧。之后程序会继续安装。 到这里，就算是安装完成了。只要在终端中没有出现红色的Err字样即表示安装成功。之后的操作亦是如此。甚至在执行命令后，若系统没有给你任何反馈，也算是执行成功。（终端比较高冷）出错了怎么办？若出现了Network字样的错误，请检查网络是否通畅，并重新执行一次命令。若依旧报网络错误，请尝试搭个梯子再尝试。若出现了Permission字样的错误，说明程序需要更高的执行权限。在执行命令的开头加上sudo和空格，再按下回车键运行，输入你的登录密码后查看运行结果。我们可以运行命令brew --version来检验一下。根据控制台输出可知，我们安装的 Homebrew 版本为 1.6.0，git仓库中的最近一次提交时间为2018-04-15。安装apache与MariaDBApache是什么Apache 是一种开源的 Web服务器软件。由于其出色的安全性、稳定性与跨平台性，成为了世界上排名数一数二的Web服务软件器，目前由Apache软件基金会维护。MariaDB是什么MariaDB数据库服务器是由MySQL的开发者原班人马打造的一款开源关系型数据库。目前已成为世界上最流行的数据库服务器软件之一。包括Wikipedia、WordPress与Google等大型网站也在使用MariaDB作为网站的数据库管理系统关于 MariaDB 的介绍，请参阅我的另一篇博文MariaDB安装说明通过Homebrew安装Apache与MariaDB我们在先前打开的终端中运行如下命令。1brew install httpd mariadb出现如图所示的提示表明安装成功。启动MariaDB服务在终端中运行如下命令1brew services restart mariadb完成后，即成功启动了 MariaDB服务器，并且重启 Mac 后依旧能正常运行。安装PHPPHP是什么PHP，全名为PHP: HyperText Preprocessor的递归缩写，是目前较为流行，应用较为广泛的面向对象动态网站开发语言。搭配 MySQL 或 MariaDB 能够开发出各类强大的网站，甚至也能开发独立的控制台程序。通过Homebrew安装PHP由于 Homebrew包管理器 的安装功能是需要软件源的支持的，这里的软件源，也就是 Homebrew 中的 tap 功能。因此在我们安装 PHP 之前，需要先导入PHP安装源。我们在终端中运行如下命令1brew tap homebrew/php耐心等待其导入完成后，运行如下命令正式安装PHP。1brew install php耐心等待它的安装，安装速度取决于你的网速。若中途出错，则重新执行该命令，重试一次即可。若连续出错，请搭个梯子再试一次。如图所示即安装成功。注意图中被选中的文字，它说的是需要手工按照说明配置 Apache服务器，才能在服务器中使用PHP。配置apache我们接下来使用 vim 工具来编辑 apache 的配置文件。当然，我们也需要屏幕上的配置信息，因此我们可以按下Command ⌘+T新建一个标签页，在新的标签页中运行命令。在终端中输入如下命令1vim /usr/local/etc/httpd/httpd.conf此时，屏幕上显示的是apache配置文件的内容。我们直接输入/LoadModule，注意大小写和正斜杠，并按下回车 ↩︎。程序的光标会自动跳转至LoadModule字样第一次出现的位置，如图所示。按下键盘上的Shift ⇧+N（即输入大写N），光标会被移至最后一次出现LoadModule的位置。如图所示，注意左下角的红色提示文本表示 查找到达文件顶部，从底部继续开始搜索。按下键盘上的O，光标会跳转至下一行开头。如图所示，注意左下角的提示变为了--INSERT--，表示程序正在插入模式。此时，我们需要之前 PHP 安装完成时屏幕上的配置信息了，按下Control ⌃+Tab ⇥切换至刚刚安装时的标签页中。若之前没有新建标签页，可以尝试新建一个终端窗口，运行命令brew info php。此时屏幕上会出现之前的配置信息。按下Command+`切换至编辑的窗口即可。如图所示我们右键复制配置信息中如图所示部分，并粘贴。按下ESC，程序会退出至命令模式。如图所示，左下角的标记消失了。我们输入/DirectoryIndex并按回车 ↩︎，光标会跳转至如图所示位置。若不是，请按N键查找下一个。按下W，光标位置会跳至如图所示位置。按下i，并输入index.php与空格，如图所示。注意左下角，目前正在插入模式。按下ESC退出至命令模式，即左下角的标记消失。输入命令:wq，并按下回车 ↩︎保存并退出程序，如图所示。到这里，我们的 Apache服务器 已经配置好了，接下来重启一下服务即可。重启Apache服务在终端中运行如下命令1brew services restart httpd如图所示表示启动成功。访问网站接下来我们到浏览器中访问地址http://127.0.0.1:8080，出现如图所示页面即表示完成。注意：输入地址时，冒号及之后的数字8080不可遗漏。8080端口改为80端口这里，我们安装的 Apache服务器 默认监听的端口为 8080，这是因为只有具有管理员权限的程序才能使用 80 端口。也就是说，只要我们以管理员身份启动 Apache服务，就能让 Apache 监听 80 端口了。具体修改方式为，使用 vim 编辑 /usr/local/etc/httpd/httpd.conf，修改其中的 Listen 8080 为 Listen 80，保存并退出。然后运行sudo brew services restart httpd 以管理员身份重启服务即可。附录到这里，我们的 Mac 已经具备了运行 PHP 网站的能力了，也为之后开发调试 PHP 网站打下了基础。这里我们还需要了解，我们的网站根目录位于1/usr/local/var/www我们可以打开一个 Finder访达 窗口，按下Command ⌘+Shift ⇧+G，输入如上地址，按下前往即可进入根目录。我们可以将自己的网站放进这个目录中，然后通过http://127.0.0.1地址访问即可。Homebrew cask当然，Homebrew 不止能安装终端程序，还能安装普通的窗口程序。举例，使用 brew 命令安装 atom 编辑器。打开一个终端窗口，运行如下命令1brew cask install atom出现如图所示画面，意思是需要输入你的登录密码后继续。输入密码后继续安装。 到这里就算是安装完成了。控制台中运行atom命令，出现 Atom 的窗口，就表示安装成功。当然，安装好的软件也能在 Launchpad启动台 和 Spotlight聚焦搜索 中找到。参考网站Vim 菜鸟教程PHP 菜鸟教程brew.shMariaDB安装说明]]></content>
      <categories>
        <category>心得分享</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP</tag>
        <tag>Mac</tag>
        <tag>brew</tag>
        <tag>xampp</tag>
        <tag>网站开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac下搭建Hexo博客]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%9C%A8Mac%E4%B8%8B%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[什么是HexoA fast, simple &amp; powerful blog frameworkHexo 是一套基于 NodeJS 的博客框架。以 MarkDown 的写文方式，快速生成属于自己的静态博客系统。在官方的 主题库 中提供大量的由设计师与开发者开发的 Hexo 主题。官方网站 hexo.io本博客就是基于 Hexo 框架开发的。如何安装 Hexo由于 Hexo 是基于 NodeJS 开发环境的，因此我们需要首先在系统中安装 NodeJS。我的系统中有没有 NodeJS？按下⌘ CMD + 空格，输入 terminal，按下回车启动终端程序。在打开的终端窗口中输入npm --version并按下回车，若出现 5.6.0 或类似的版本号，说明系统中已经存在 NodeJS，无需安装。如图所示什么是 NodeJSNodeJS 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，使用 npm 来作为包管理系统，可以使用其来开发专业的前后端应用程序。参阅 Node.JS 中文网使用 Homebrew 来安装 Node（已安装可跳过）在 Mac 系统下安装 NodeJS，有两种方法。第一种是直接从官网上下载 PKG 安装程序进行安装，第二种是使用 brew 包管理系统进行安装。什么是 Homebrew？Mac 系统默认自带的命令行工具不全面。若要安装第三方软件包，需要使用类似于 Linux 系统下的 APT、YUM 等包管理系统。这个包管理系统，也就是 Homebrew。要安装 Homebrew 包管理系统，请打开一个终端，输入如下命令，并按下回车后进行安装：1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"官网 Homebrew。由于 Homebrew 能帮助我们统一地管理各个包与相互的依赖关系，因此我个人推荐使用 Homebrew 来安装 NodeJS。本文中也将使用该方法来进行安装。打开终端窗口，输入如下指令1brew install node若提示-bash: brew: command not found，则表示还未安装 Homebrew。请参考前半段，安装 Homebrew。按下回车运行后，出现类似如图所示输出。再输入 npm --version ，按下回车，出现如上一章中的输出，则表示 NodeJS 安装成功。只要输出中没有包含Err字样即表示安装成功若提示Access denied或者Permission denied等字样，表示没有权限。请运行 sudo -i 命令，输入你的登录密码，按下回车之后，再重新执行以上命令。注：你输入的密码是不会回显在屏幕上的，也不会显示*，不要以为不能输入若出现Network Error等字样表示网络故障，可稍后再试，或者搭个梯子再安装。安装 Hexo 命令行工具Hexo 博客框架提供了便捷的命令行工具hexo-cli来初始化博客、创建文章、创建页面等操作。这次，我们需要使用 npm 命令来安装 hexo 命令行工具。在打开的终端中运行如下命令1npm -g install hexo-cli系统提示随后运行hexo --version出现如图所示输出即表示 Hexo 命令行工具已安装完成。由于我们的 NodeJS 版本可能不同，因此输出结果也可能不一致。只要没出现 Err 字样即表示 安装成功。生成我们的 Hexo 博客每一个 Hexo 的博客都可以方便地使用我们刚刚安装的 Hexo 命令行工具进行初始化，每一个目录均可以作为一个 Hexo 博客的根目录。那么，我们首先进行初始化动作。初始化博客我们打开终端，运行mkdir -p ~/hexo &amp;&amp; cd ~/hexo这一步操作是在用户目录下创建一个名为 hexo 的目录，并进入至这个目录中。我们继续运行命令hexo init ./，开始使用hexo工具初始化一个博客。这里根据网络情况，可能耗时会比较漫长，耐心等待即可。倘若出现了红色 Err 字样，表示初始化出错。此时需要运行rm -R * &amp;&amp; rm -R .*命令删除目录下所有文件，然后重试。多次失败请搭个梯子再重试。看看博客长啥样继续在终端中运行hexo s，启动 Hexo 自带的 HTTP服务器。输出如图表示服务器启动成功，您可以打开浏览器访问地址http://localhost:4000访问自己的博客。倘若出现如图所示错误，表示 4000 端口被占用，请使用 netstat命令检查端口占用情况，终止占用端口的程序。或者运行hexo s -p 4001命令，更换服务器端口为 4001。相应地，访问地址也变为http://localhost:4001这里的4001可更改为任意一个没有被使用的端口号。恭喜您，我们已经成功地搭建了一个自己的博客系统。要停止我们的博客服务器，在终端中按下⌃ CTRL+C管理博客内的文章编写一篇新文章我们可以使用hexo new post 文章标题命令来创建一篇文章。如图所示，我们创建了一篇名为《在Mac下搭建Hexo博客》的文章，并且程序也输出了所创建的文件是~/hexo/source/_posts/在Mac下搭建Hexo博客.md。由此我们也知道了博客内的所有文章都在source/_posts目录中。接下来我们运行如下命令1open ./source/_posts系统会弹出一个位于 ./source/_posts 的 Finder 窗口，我们可以看到有两篇文章。我们使用自己习惯的编辑器打开要编写的文章文件，例如：在Mac下搭建Hexo博客.md。这里我使用的编辑器是 MacDown。我们可以看到文件内已经拥有了一些内容，格式如下1234567---title: 文章标题date: 文章的编写日期，格式：Y-m-d H:itags: 文章标签，格式：[标签1, 标签2, 标签3，……]categories: 文章分类，格式：[分类名1, 分类名2, 分类名3, ……]description: 文章描述---这些也是文章的属性。这些属性中：title 属性是必不可少的，其他均可以省略。接下来可以开始你的编写博客之旅了，使用 MarkDown 语法编写自己的第一篇博客。写完之后别忘了按⌘ CMD+S保存哦！查看我写的文章在编写好文章之后，我们可以在终端中运行hexo s命令启动服务器，在浏览器中查看我们的博客。注意：你运行 hexo s 命令时，终端所在目录必须是一个 Hexo 博客根目录，本文中应该是 ~/hexo。若出现如图所示错误则先执行cd ~/hexo命令切换至博客目录。 删除一篇文章要是觉得某篇文章不想要了，直接在 Finder 中把文章的.md文件删除即可。发布我的博客我们之前所启动的服务器是 Hexo 内置的服务器，功能有限，不适合作为生产环境的服务器，因此我们需要更换服务器。而在更换服务器之前，我们需要将博客发布出来，也就是生成最终的.html静态网页与相关.css、.js等资源文件。生成静态文件的命令是1hexo generate而生成的静态文件，则被放置在 public 目录下。也就是~/hexo/public。我们只需要安装配置好服务器，将网站的根目录指向该目录即可。注意：虽然在 public 目录下是博客网站的根目录，也有全部的静态资源文件，但是由于文件引用的关系，即.html文件中对资源文件的引用全部是绝对引用，直接双击打开index.html，浏览器会寻找不到被引用的资源文件，因此展现给我们的并不是一个有完整样式的网页。而如果我们使用网站服务器，将网站的根目录指向为该目录，则访问时就不会发生引用错误，能正常访问。给我们的博客换皮肤刚安装好的博客外观不是那么得简洁出众。不过好在官方提供了主题库，其中拥有大量优秀的主题供我们使用。我们在这里演示安装 NexT 主题。NexT 主题的 GitHub 官网为theme-next/hexo-theme-next安装NexT主题我们首先在终端中切换至我们的博客根目录1cd ~/hexo然后运行1git clone https://github.com/theme-next/hexo-theme-next themes/next这里可能也需要耐心等待一小会儿。启用下载的主题安装好后，运行1vim _config.yml这里启动了 Vim 编辑器，打开了 _config.yml 博客配置文件。我们需要在配置中，修改主题设置为next。在键盘上直接输入1/theme:然后按下回车键这里执行的动作为，按下/进入搜索模式，搜索关键字为theme:。这里光标已经定位到了theme:的位置。我们输入1yyp这里首先输入yy复制了光标所在的行，然后按下p粘贴至下一行然后我们按下i，进入插入模式。注意此时终端窗口左下角显示为--INSERT--，表示 Vim 正处于插入模式。我们使用上下左右方向键移动光标，直接如图修改这两行。注意：冒号为英文冒号，冒号后有一个空格，注意大小写注意此时左下角依旧是--INSERT--。若误操作退出了插入模式，也就是左下角的符号消失了，那么此时可以按下i再次进入编辑模式。此时按下ESC，退出编辑模式。输入:wq回车。此时执行的操作为：按下:进入末行模式，w表示保存，q表示退出。若按下回车后终端窗口没有返回至命令界面，请检查当前的输入模式是否是默认的普通模式，即左下角为没有任何提示的模式。关于 Vim 编辑器的更多帮助，请参阅Vim菜鸟教程此时运行hexo s命令启动服务器，并在浏览器中打开http://localhost:4000此时可以看到博客界面已经变为简洁的 NexT 主题了。关于_config.yml文件的说明，请参阅Hexo文档我们的主题也有自己的配置文件，位于theme/next/_config.yml。可以修改这个配置文件来使我们的博客与众不同。关于主题配置文件的说明，请参阅主题配置 - NexT使用文档附录执行的命令编号命令说明1brew install node安装 NodeJS2npm -g install hexo-cli安装 hexo 命令行工具3mkdir -p ~/hexo &amp;&amp; cd ~/hexo建立博客根目录4hexo init ./初始化博客5hexo new post 文章名称新建一篇文章6hexo s启动 Hexo 服务器7git clone https://github.com/theme-next/hexo-theme-next themes/next下载 NexT 主题8vim _config.yml编辑站点配置文件Windows 与 Linux（Ubuntu、CentOS）下的安装Windows 下自行前往 NodeJS 官网下载 NodeJS 的Windows安装包进行安装，然后打开命令提示符，从npm -g install hexo-cli开始继续操作。Linux 下，将文中命令中的brew替换为apt(Ubuntu)或yum(CentOS)即可。相关网站MarkDown教程Homebrew下载NodeJSHexo中文官网NexT主题官网NexT主题GitHub官网Vim菜鸟教程]]></content>
      <categories>
        <category>心得分享</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mac</tag>
        <tag>node</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MariaDB安装说明]]></title>
    <url>%2F2018%2F03%2F11%2FMariaDB%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[MariaDB是什么在了解MariaDB之前，先来介绍一下MySQL。MySQL是什么？MySQL是世界上最流行的一款开源关系型数据库管理系统之一。可以帮助各类企业、组织与个人开发出具有高性能、可扩展的数据库应用程序参阅：https://www.mysql.com/products/由于其安装便捷、成本低、资源开销小，从其诞生之初就被各类网站开发者所青睐。MariaDBMariaDB数据库服务器是由MySQL的开发者原班人马打造的一款开源关系型数据库。目前已成为世界上最流行的数据库服务器软件之一。包括Wikipedia、WordPress与Google等大型网站也在使用MariaDB作为网站的数据库管理系统参阅：https://mariadb.org/about/MariaDB优点MariaDB 用有更多的存储引擎MariaDB 的处理速度相比 MySQL 提升了200%MariaDB 中引入了更多强大的功能扩展修补了大量在MySQL中存在的Bug完全开源，拥有完善的社区支持MySQL也开源，但是自从MySQL被Oracle收购后，社区担心Oracle会在未来添加某些新功能至付费版中，所以fork出了一个新版本，也就是 MariaDB，以便于在这种情况发生时，社区也能很快开发出相兼容的功能至 MariaDB 中继续为社区服务。参阅：MariaDB versus MySQL - Features为什么 Oracle 收购 MySQL 后仍保证其开源免费？MariaDB参考网站菜鸟教程w3schoolStackOverflowMariaDB Knowledge Base安装MariaDB工欲善其事，必先利其器。在使用数据库系统之前，为了得到更好的性能与更少的系统本身错误率，必定要先安装最新版本的系统。MariaDB数据库系统支持跨平台运行，能够在Windows、Linux与Mac系统上运行。我们先来看Windows下的安装Windows下的安装下载打开链接Downloads - MariaDB能够看到下图的页面由页面可知能够下载到的MariaDB版本为10.2稳定版、10.3开发版以及10.1及以下的稳定版。通常，在 生产（正式）环境 中，需要保证系统接近绝对的稳定，所以需要下载稳定版；而对于我们程序员来说，在 开发阶段，需要部署安装的最好是最新版，以保证未来的程序兼容性，所以可以选择最新版。在这里，我们下载 最新版。点击Download 10.3.5 Release Candidate Now!按钮，也就是下载 10.3开发版。这里能够看到官方提供了多种平台下的安装包，我们选择Windows版，点击mariadb-10.3.5-winx64.msi。这里，网站会要求我们输入一些个人信息以用于作官方的统计，这里我们不输入，点击No thanks, just take me to the download白色按钮开始下载。安装下载的文件如图所示，直接双击打开。首先出现的是安装程序的欢迎界面，我们直接点击 Next 继续。阅读软件许可协议，点击 I accept the terms……，然后点击 Next 继续。这一步是选择要安装的 组件 以及软件的 安装目录。我们可以点击 Browse 按钮选择一个要安装到的目录，然后点击 Next 继续。这里的组件中，HeidiSQL是一个简易的开源数据库可视化管理程序，类似于 SQL Server Management Studio，能够直观地看到系统中的数据表信息以及各条记录，我们可以保持默认勾选上以安装。这个界面，是要求你输入默认的root账号的密码，密码可以为空。Root账号是 MariaDB数据库 中权限最大的管理员账号，其他用户以及各自的权限都由root用户直接添加与指派。当root密码丢失后，则需要使用 mysqladmin工具 进行无密码登录并重置，操作不当还可能需要重新安装数据库，所以设置密码请务必牢记。鼠标所指的选项是 为root账户启用远程登录权限 。默认地，在不勾选的情况下，root账号只能在本机（127.0.0.1）进行登录，无论是 局域网内的 还是在 互联网上的 其他电脑，均无法登录到root账号，这也是为了数据库系统的安全考虑。若要将本机打造为数据库服务器，可为其他电脑提供服务，则勾选此项。最后的 Use UTF8 as default server…… 选项的意思是将UTF8编码用作是服务器的默认字符编码。众所周知，计算机中的字符文本都是以一个通用的编码保存在系统中的，而 UTF8 编码则是目前较流行的字符编码，其所包含的字符数量较多，覆盖的语言较为全面，能够满足大部分人的需求，因此我们勾选上这个选项。我们输入想要设置的密码后，点击 Next 按钮继续。这里出现的窗口，是需要我们指定数据库程序在系统中的服务名、TCP端口号、Innodb引擎的缓冲池大小与Innodb引擎的页面大小等设置，保持默认即可。直接点击 Next 继续。这一步是询问我们是否启用 反馈插件 以自动向官方发送匿名的统计信息。官方能够使用这个信息来发现系统中存在的漏洞以及潜在的性能瓶颈。本着 人人为我，我为人人 的互联网精神，就保持默认，勾选上，点击 Next 继续，再下一个窗口中点击 Install 按钮开始安装。安装过程中可能会出现如图所示的提示，意思是安装程序需要提升为管理员权限，点击确定按钮继续，否则程序无法安装服务，导致安装失败。当看到如图所示的Complete界面，表示安装完成，点击 Finish 按钮关闭窗口即可。测试如果勾选安装了 HeidiSQL组件，则会在桌面上出现这个图标，双击启动 HeidiSQL。点击左下角的新建按钮添加一个会话，左侧会话名称这边输入自己喜欢的，例如：local；右侧保持默认，密码字段输入自己安装时设置的密码，然后点击左下角的保存按钮，再点击右下角的打开按钮连接。当出现如图所示界面，表示MariaDB安装成功，并已经成功连接至MariaDB服务器。至此，恭喜你，你已经成功地在 Windows 中安装了MariaDB数据库管理系统。Linux下的安装Linux系统拥有众多的发行版，例如 Ubuntu、CentOS、RedHat 等。目前主流的发行版是 Ubuntu 与 CentOS 系统。在这里我们介绍这两个平台下的安装方法。在Linux的各个发行版中，一般都自带了一套 包管理系统 用来管理系统中的软件包。Ubuntu 下使用的是 APT 包管理系统，而 CentOS 中使用的是 YUM 包管理系统。通常，我们利用自带的 包管理系统 即可快速地安装 MariaDB。Ubuntu（APT包管理系统）下的安装打开终端，输入apt update &amp;&amp; apt install mariadb-server命令并按下回车键。出现如图所示的提示符，意思是安装需要下载 21.7MB 的数据，安装完成后将会额外消耗 178MB 的容量。输入y再按回车即可继续操作。当然，我们可以看到[Y/n]中的Y为大小，表示这是 默认操作，也就是说我们也可以直接按下回车即可继续操作。系统正在安装。到这一步，没有看见Error字样的输出，就表示MariaDB已经安装完成了，我们接下来进行配置服务器。终端中输入service mysql restart并按回车键。然后在终端中输入mysql_secure_installation并按回车键。这里会要求我们输入当前的 root 账号密码，由于是首次安装，所以不用输入，直接按回车键。这里系统询问我们是否需要设置 root 账号的密码，我们可以输入n并按回车表示不设置密码，在这里我们直接按回车选择设置密码。想想为什么可以直接按回车表示Y呢？接下来请输入想要指定的 root 账号密码。注意：Linux系统下输入密码时，是不回回显给你看的，也不会像Windows中一样，显示*，所以请仔细输入密码，完成后按下回车。然后出现Re-enter new password，这里请重复输入刚刚设置的密码，并按回车键提交。若重复密码不一致，会要求你再次设置密码。这里系统询问你是否需要移除 匿名用户。默认地，我们不需要使用该账户，因此直接按下回车移除即可。这里系统询问你是否需要禁止 root 账户的远程登录权限，为了系统的安全起见，建议直接按回车禁止；当然，若要将系统作为数据库服务器为其他计算机服务，则输入n回车，允许 root 用户的远程登录。这里我们直接按回车继续。是否需要移除 test 数据库以及对它的访问？我们不需要测试数据库，直接按下回车继续。是否需要重新加载权限表？这里是让系统重新加载各个用户的权限，我们直接按回车继续。安装完成。我们可以在命令行中输入mysql -uroot -p回车，然后输入你刚刚设置的密码来测试。成功连接至服务器，我们输入exit回车即可退出。CentOS（YUM包管理系统）下的安装打开终端，输入yum install mariadb-server，回车。这里系统提示总共需要下载 20MB 的数据，安装 107MB 的数据。我们输入y并按回车确定。为什么不能直接按回车了呢？继续在控制台输入systemctl restart mariadb.service回车。然后输入mysql_secure_installation回车运行配置程序。接下来就参考 Ubuntu（APT包管理系统）下的安装 章节中 mysql_secure_installation配置 部分即可。Mac下的安装Mac系统下默认自带了一个mysql服务器，但是它不是最新版，而且由于其直接整合在系统中，也没有自带 APT、YUM 等方便的包管理系统来管理系统中的包，因此不便于更新。所以我们需要首先安装一款第三方的包管理系统：brew，然后通过 brew 来安装MariaDB。已安装 brew 的同学可以跳到后续的章节阅读。安装brew包管理系统按下 CMD + 空格 打开 Spotlight Search，输入 terminal 回车打开终端程序。 如图，输入/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;并按回车。然后出现ENTER后继续按回车。到这一步需要你输入账户的密码，按回车键确认，然后开始安装。Mac为类Unix系统，控制台中输入密码时与Linux一样，不会回显密码或*。然后系统会继续完成安装。完成后，在命令行中输入brew回车，看到如图的输出，即表示 brew 安装成功通过 brew 安装 MariaDB在终端中输入命令brew install mariadb回车。出现这一步，表示安装成功。然后继续输入命令brew link mariadb回车，sudo mysql_install_db回车，安装系统数据库；若出现 password 则输入自己账户的密码，按回车继续。安装好后，输入brew services start mariadb启动服务。最后一步，与 Linux 下的安装一样，需要运行mysql_secure_installation工具初始化。参考 Ubuntu（APT包管理系统）下的安装 章节中 mysql_secure_installation配置 部分即可。完成后至此，我们已经在系统中安装好 MariaDB 数据库系统并已配置完毕。接下来就靠大家自己学习如何利用好 MariaDB 这把利剑了。给你们一些参考知识MariaDB/MySQL 的绝配 PHPPHP菜鸟教程Python菜鸟教程如何安装 ComposerLinux教程PackigistLaravelGithub上的LaravelWindows下的附录Windows下安装好后，不能直接在终端（命令提示符）中使用 mariadb 提供的命令行工具，需要我们手工配置系统的 PATH 环境变量才行。右键桌面上的 此电脑 图标，点击属性。点击左侧的 高级系统设置 ，再在弹出的窗口中点击 环境变量 按钮。双击下面的 Path 变量。点击右侧的 新建 按钮，在左侧列表项中输入 C:\Program Files\MariaDB 10.3\bin 回车。注意：这里的 C:\Program Files\MariaDB 10.3\ 为你安装时指定的MariaDB安装目录随后一路点击 确定 按钮，关闭所有窗口。打开开始菜单，输入 cmd 回车，打开 命令提示符。输入 mysql --version 回车。若出现如图所示的反馈文本，说明已配置成功，能够正常使用命令行工具了，否则请检查 Path 环境变量的值是否正确。这里的 cmd 命令提示符工具可以使用新版的 PowerShell 工具]]></content>
      <categories>
        <category>MariaDB/MySQL</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MariaDB</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python图形库基础]]></title>
    <url>%2F2018%2F03%2F10%2FPython%E5%9B%BE%E5%BD%A2%E5%BA%93%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[Python模块如何安装Python模块可以通过pip工具直接安装打开终端（命令提示符），输入如下指令1pip install matplotlib其中 matplotlib 为你想要安装的图形库，例如 matplotlib若没有出现Error字样的输出，就表明安装成功如何在程序中导入所安装的模块新建一个文件，文件开头的 import 导入语句部分输入如下指令1import matplotlib.pyplot as plt其中，matplotlib.pyplot 为你想要使用的 模块名。其后的 as plt 表示将导入的模块重命名为 plt，以便于我们接下来使用该库。有的模块名包含很多子功能，比如 matplotlib 模块中包含有一个 pyplot 的子功能，那么此时，我们只能挨个导入该模块中的子功能。多条导入语句可以合并：1import numpy as np, matplotlib.pyplot as plt使用Numpy模块生成数据12345import numpy as npx = np.linspace(-np.pi, np.pi, 256, endpoint=True) # 均分数据，生成从 -π~π 之间的256个数据，包括端点，返回 List 对象print(x)C, S = np.cos(x), np.sin(x) # 对 List 生成 cos 数组与 sin 数组print(C, S)运行结果 参考：http://blog.csdn.net/you_are_my_dream/article/details/53493752Matplotlib库plot函数函数声明为：matplotlib.pyplot.plot(*args, **kwargs)函数本身的参数数量不限。通常，第一个参数为所画线段上每一个点的横坐标 List/Array，第二个参数为所画线段上每一个点的纵坐标 List/Array；当省略第二个参数时，第一个参数中的元素则变为所画线上的每一个点的纵坐标值，横坐标变为该元素的数组下标（索引）例：123456import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-np.pi, np.pi, 256, endpoint=True) # 均分数据，生成从 -π~π 之间的256个数据，包括端点，返回 List 对象print(x)plt.plot(x)plt.show()运行结果除了横坐标纵坐标参数之外，还有其他常用的参数。例如color 线条颜色固定颜色描述颜色英文全称颜色十六进制代码颜色RGBA值Tuplelinewidth 线条宽度linestyle 线条类型更多其他参数参考：Matplotlib Plot绘制正余弦曲线思路：使用 Numpy 模块的 linspace 函数创建某个要显示的线条 x 值区间，例如 [-π, π]，使用 Numpy 模块的数学函数 cos 与 sin 函数生成 x 值所对应的 y 值区间使用 plot 函数画图代码12345678import numpy as npimport matplotlib.pyplot as pltx = np.linspace(-np.pi, np.pi, 256, endpoint=True)C, S = np.cos(x), np.sin(x)plt.plot(x, C)plt.plot(x, S)plt.show()运行结果修改线条宽度、颜色12plt.plot(x,C,color='red',linewidth=2.5,linestyle='-') plt.plot(x,S,color='blue',linewidth=2.5,linestyle='-')完整代码1234567import numpy as np, matplotlib.pyplot as pltx = np.linspace(-np.pi, np.pi, 256, endpoint=True)C, S = np.cos(x), np.sin(x)plt.plot(x, C, color='red', linewidth=2.5, linestyle='-')plt.plot(x, S, color='blue', linewidth=2.5, linestyle='-')plt.show()运行结果绘制饼图代码12345678910import matplotlib.pyplot as pltlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'。# 设置板块标题sizes = [15, 30, 45, 10] # 设置每一个板块的所占比例explode = (0, 0.1, 0, 0) # 设置每一个板块的突出距离plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90) # 以 `sizes`、`explode`、`labels` 参数创建一个饼图，将数值以"%1.1f"的格式作为标签显示在板块中心，打开图片阴影，起始角度为 90度。plt.axis('equal') # E将画布的坐标缩放值改为等比例，以显示完整的正圆形饼图plt.show()运行结果使用Matplotlib模块与sklearn模块学习鸢尾花类型特征本次使用的机器学习算法为 Logistic回归三种颜色代表三种鸢尾花类型：山鸢尾、杂色鸢尾 与 维吉尼亚鸢尾所取特征为：萼片长度 与 萼片宽度123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn import datasets, linear_modeliris = datasets.load_iris()x = iris.data[:, :2]y = iris.targeth = 0.02 # step size in the mesh# colormapcmap_light = ListedColormap(['#FFAAAA', '#AAFFAA', '#AAAAFF'])cmap_bold = ListedColormap(['#FF0000', '#00FF00', '#0000FF'])# Logistic回归模型lgm = linear_model.LogisticRegression()# fitlgm.fit(x, y)# Plot the decision boundary.# point in the mesh [x_min, x_max]x[y_min, y_max].x_min, x_max = x[:, 0].min() - 1, x[:, 0].max() + 1y_min, y_max = x[:, 1].min() - 1, x[:, 1].max() + 1xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))# predictz = lgm.predict(np.c_[xx.ravel(), yy.ravel()])# Put the result into a color plotz = z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx, yy, z, cmap=cmap_light)# Plot also the training pointsplt.scatter(x[:, 0], x[:, 1], c=y, cmap=cmap_bold, edgecolor='k', s=20)plt.show()运行效果三种颜色代表三种鸢尾花类型Graphviz模块Dot脚本语言用于在 Graphviz 程序中绘图的一门语言。根据 Dot 脚本能够实现各种关系图、流程图等图片。示例123456789101112131415161718192021222324// 数据挖掘与机器学习digraph &#123; A [label=Python] B [label=&quot;爬虫&quot;] C [label=&quot;机器学习&quot;] D [label=&quot;数据预测&quot;] E [label=&quot;数据分析&quot;] F [label=&quot;网站开发&quot;] G [label=HTML] H [label=CSS] I [label=JS] J [label=ES5] K [label=ES6] A -&gt; B A -&gt; C A -&gt; D A -&gt; E A -&gt; F F -&gt; G F -&gt; H F -&gt; I I -&gt; J I -&gt; K&#125;详细使用说明请参考http://blog.csdn.net/jy692405180/article/details/52077979Python中的使用在 Python 中使用 Graphviz 模块会自动生成后缀名为 .gv 的 dot 语言文件与 .pdf 输出文件。首先需要你正确安装 Graphviz 应用程序，graphviz 模块才能正常工作示例代码1234567891011121314151617181920212223242526272829from graphviz import Digraphdot = Digraph(comment='数据挖掘与机器学习')# 添加圆点 A, A的标签是 Pythondot.node('A', 'Python')dot.node('B', '爬虫')dot.node('C', '机器学习')dot.node('D', '数据预测')dot.node('E', '数据分析')dot.node('F', '网站开发')dot.node('G', 'HTML')dot.node('H', 'CSS')dot.node('I', 'JS')dot.node('J', 'ES5')dot.node('K', 'ES6')dot.edges(['AB', 'AC', 'AD', 'AE', 'AF', 'FG', 'FH', 'FI', 'IJ', 'IK'])dot.view()# 获取DOT source源码的字符串形式print(dot.source)运行结果更多示例请参考：http://www.graphviz.org/gallery/附录更多关于 Python 图形库的信息，可参考：https://pypi.python.org/pypi?%3Aaction=search&amp;term=visual&amp;submit=searchPython 相关网站PythonPython Packages IndexPython 菜鸟教程Django框架Django菜鸟教程Scikit-learn]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>大数据</tag>
        <tag>数据挖掘</tag>
        <tag>图形</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap与响应式布局初步]]></title>
    <url>%2F2018%2F03%2F02%2FBootstrap%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[什么是BootstrapBootstrap最初是由 Twitter 的设计师与工程师共同开发的一款开源前端框架，最初于2010年诞生。最初发布之时，其名称为 Twitter Blueprint，且不开源，仅作为公司内部的样式指南使用。之后经过了几个月的完善，在同年的首届 Hack Week 大会上对外发布。之后在2011年，官方正式发布并开源该项目，经过了20多个版本的迭代，目前已经成为了世界上最流行的前端框架。参考：https://getbootstrap.com/docs/4.0/about/overview/为何使用BootstrapBootstrap是目前最流行的前端框架之一。它的成功离不开如下几点：移动优先。意味着使用 Bootstrap 开发出的网站效果能够更好地适应手机端、平板端等小屏幕。这在如今日趋移动化的世界中无疑是颗甜美的糖果。快速布局。凭借着自带强大的响应式网格系统，能够快速实现出排版规范工整的页面。配合强大的响应式工具，能够快速实现多种分辨率的适配。面向所有人。对于前端初学者来说，最头疼的莫过于解决布局错乱了。好在 Bootstrap 已经为我们写了全套的 CSS 代码，我们只需要使用其提供的 class 类名即可。参考：https://getbootstrap.com/docs/3.3/如何获取BootstrapBootstrap 的源码使用 LESS 与 SASS 语言编写，我们可以从 GitHub 网上下载 Bootstrap 的源码包，自行使用 LESS 或 SASS 编译器编译，生成 CSS 文件来使用。当然，这显然不是初学者想做的。当然，我们也能下载官方编译好的 发行版（release）：Bootstrap v3 或 Bootstrap v4。解压完成后即是 Bootstrap 的 css 与 js 文件。我们在 HTML 文件中直接引入即可。注意：对于开发来说，为了保证未来的可持续发展，我个人比较崇尚的是使用最新版来开发。但是这里我建议各位下载两个版本来开发，也就是 v3 与 v4 两个版本。为什么要下载两个版本，而且都要学习：Bootstrap 的 v4 版本是今年（2018年）才正式发布的，与2013年就正式发布的 v3 版相比，市场占有率不具备可比性，目前大部分网站使用的 Bootstrap 版本依旧是 v3 版。因此还是建议各位先学习 v3 版，再学习 v4 版。在这里，我们仅介绍 v3 版本。还有一种更偷懒的，Bootstrap 官方为我们提供了免费的 CDN 加速服务，我们可以直接使用 CDN 上的 Bootstrap。v3 版123456&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt;&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;v4 版1234&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"&gt;&lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"&gt;&lt;/script&gt;最后一种，是稍高端又不失便利的安装方法，通过 包管理器 自动安装。通过 Bower 进行安装1$ bower install bootstrap通过 npm 进行安装1$ npm install bootstrap通过 Composer 进行安装1$ composer require twbs/bootstrap具体请参考：https://v3.bootcss.com/getting-started/如何使用Bootstrap首先新建一个空的HTML文件，在文件中编写一个简单的网页框架。12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的第一个Bootstrap网站&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;关于 HTML、CSS 的基础知识，请自行通过网络或参考书来自学。例如：程序虫的日常、网页客研究会、w3school、菜鸟教程等。在这里，我们假设你已经掌握了 HTML 与 CSS 的基础知识。其次，在网页中引入我们下载的或位于CDN上的 Bootstrap 的相关文件。同时，由于 Bootstrap 是基于 jQuery 的，所以也别忘了引入 jQuery 文件。这里我们使用 CDN 上的 Bootstrap 框架与 jQuery。关于CDN请参考：BootCDN1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="zh-hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的第一个Bootstrap网站&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;注意：我们把所有的 CSS 文件均放置在 head 标签中，而 JS 文件则放置在 body 标签中。为什么：因为根据页面的加载顺序，浏览器会首先加载 先出现的文件，并 执行。假设我们把 JS 文件均放置在head标签中，那么，浏览器在读取页面时，首先遇到的便是 JS 文件，并开始执行 JS 代码。这时，浏览器的渲染引擎会被阻塞，JS 引擎会优先执行。倘若 JS 代码被阻塞，那么浏览器的渲染也停止，用户则看不到完整的，经过精心调教的页面。这样，对用户的体验就不好了。此时我们保存我们的文件，在浏览器中打开，按下F12键打开 控制台，会看到如图页面。页面与控制台中均无报错信息。此时说明我们的框架已被正确安装。Bootstrap的网格系统Bootstrap 自带了一套强大的响应式12网格系统，我们可以使用它来搭建页面的框架。12网格系统就意味着该网格系统会将页面的每一行分为12列，每一行中的列最多占用12列。超出的列将自动换行。Container容器首先，网格系统的最外层是一个大的容器，类名为container。我们可以先做一个小实验，看一下 容器 长什么样。在之前的代码基础上添加如下代码CSS123.container &#123; background: #EEE;&#125;记得将 CSS 代码包围在 style 标签中，并写在 head 标签里。HTML123&lt;div class="container"&gt; &lt;p class="text-danger"&gt;我是一个Container&lt;/p&gt;&lt;/div&gt;这里我们使用了 text-danger 类来设置字体颜色为 危险的红色。类似的还有text-warning黄色、text-success绿色、text-primary蓝色、text-info深蓝色、text-primary蓝色、text-muted灰色等。请参考：Bootstrap 辅助类完整代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="zh-hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的第一个Bootstrap网站&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt; &lt;style&gt; .container &#123; background: #EEE; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;p class="text-danger"&gt;我是一个Container&lt;/p&gt;&lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;保存后，在浏览器中运行。可以看到页面中出现了一个灰色的框，其中有一行红色的字。这个灰色的框即使我们的Container容器。当然，默认地，是没有灰色背景的，这里我们手工添加了背景以便于观察。我们在开头就说了，Bootstrap 是支持响应式布局的。那么何为响应式？我们先将浏览器的窗口最大化，然后逐渐缩小宽度，观察 灰色区域 的大小。我们会注意到如下几种情况 可以看到，Container的灰色区域会随着浏览器宽度的变化而变化，直至充满页面宽度不变。这个，就是响应式的一种体现，要求页面的内容能够随着客户端视口的大小变化而变化。视口Viewport，是浏览器的用户可视区域。具体请参阅：http://www.css88.com/archives/5975什么？你的页面内容无变化？请尝试添加如下代码至head标签中的第一个meta标签之后。1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"&gt;此时你的代码类似于12345&lt;!DOCTYPE html&gt;&lt;html lang="zh-hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"&gt;此时，保存后再刷新页面看看，是不是有效了。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;代码的意思是告诉浏览器如何去设置 视口。这里我们设置了 视口 的宽度为 设备宽度，最初的缩放比例为 1.0 且用户 不可手工缩放。这样的话，就能够启用页面的响应式功能，并且让 CSS 能够得到正确的 视口 大小。那么，由此可看出，默认的容器会随着浏览器窗口的宽度变化而变化，如果我们想做通栏的网站该怎么办呢？我们使用第二个容器container-fluid。我们修改以上代码中的 container，改为 container-fluid。此时代码如下1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"&gt; &lt;title&gt;我的第一个Bootstrap网站&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt; &lt;style&gt; .container-fluid &#123; background: #EEE; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container-fluid"&gt; &lt;p class="text-info"&gt;我是一个Container&lt;/p&gt;&lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;保存运行，再改变浏览器大小看看效果。 会发现无论我们如何缩放浏览器大小，灰色区域始终是充满页面宽度的，这个就是 Bootstrap 的第二个容器。Row行与Col列容器是网格系统的基础，那么 Bootstrap 中的网格系统的精髓部分，则就是 Row 行与 Col 列了。借助这两个元素，我们能够快速创建出能够响应式的变化的网站。根据 Bootstrap 的 最佳实践，Row 应该处于一个 Container 容器中，而 Col 列则应该位于一个 Row 行之中。我们看一个示例12345678.col-lg-4 &#123; min-height: 50px; background: #AFA;&#125;.col-lg-4:nth-child(even)&#123; background: #FFA;&#125;1234567&lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;完整代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt; &lt;style&gt; .container-fluid &#123; background: #EEE; &#125; .col-lg-4 &#123; min-height: 50px; background: #AFA; &#125; .col-lg-4:nth-child(even)&#123; background: #FFA; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;&lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;&lt;/div&gt; &lt;/div&gt; &lt;p class="text-danger"&gt;我是一个Container&lt;/p&gt; &lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;运行效果大屏幕下中屏幕下小屏幕下可以看到，浏览器中出现了三个颜色不同的色块。这里每个色块都是页面中的某 一列。代码中对应的，就是类名为 col- 开头的元素.123&lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;&lt;/div&gt;&lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;&lt;/div&gt;&lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;&lt;/div&gt;这里，我们使用的容器为 container-fluid 容器，也就是能够占满页面宽度的容器。你可以尝试着将 container-fluid 修改为 container 查看运行结果会变成什么样。那么，我们的 行 呢？修改代码，给每一个色块中加一些文字123&lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;我是列1&lt;/div&gt;&lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;我是列2&lt;/div&gt;&lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;我是列3&lt;/div&gt;完整代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"&gt; &lt;style&gt; .container-fluid &#123; background: #EEE; &#125; .col-lg-4 &#123; min-height: 50px; background: #AFA; &#125; .col-lg-4:nth-child(even)&#123; background: #FFA; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;我是列1&lt;/div&gt; &lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;我是列2&lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;我是列3&lt;/div&gt; &lt;/div&gt; &lt;p class="text-danger"&gt;我是一个Container&lt;/p&gt; &lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;运行结果此时我们可以看到色块与文字均占满了浏览器宽度我们再次修改代码，将代码中的 row 改为一个不存在的类，例如 row-1。12345&lt;div class="row-1"&gt; &lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;我是列1&lt;/div&gt; &lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;我是列2&lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;我是列3&lt;/div&gt;&lt;/div&gt;运行结果可以看到，在列的两边各多出了一块灰色区域，我们的 列 没有占满整个浏览器宽度。我们可以通过 审查元素 查看 row 与 container 的 CSS 代码。123456789.container, .container-fluid &#123; padding-right: 15px; padding-left: 15px;&#125;.row &#123; margin-right: -15px; margin-left: -15px&#125;Container 的盒子模型Row 的盒子模型我们由此可知，container 容器中的左右两边均有 15px 的 内边距，而 row 行的左右两边均有 -15px 的 外边距。两者会相互抵消，使得 row 行中的列能够占满 容器。这里会有一个问题，为什么 row 要有 -15px 的外边距，container 要有 15px 的内边距？直接设为 0 不是能够更省事吗？我们需要注意，网格系统不一定要严格包含 row 与 col 的。我们可以将 container 单独使用，作为我们页面中的某个板块的容器来使用。此时，我们的板块中可以是一张图片，一段文字，或其他你想展现的信息。而这时，container 的15px的内边距能够使你的内容不会顶格，与两边会有一定的留白，使页面更美观。初步了解了 Bootstrap 中的 容器、行 与 列，那么我们接下来就可以学习如何实现响应式页面了。使用Bootstrap实现响应式布局在了解 如何做 之前，我们先来了解一些概念，到底什么是 响应式布局？何为响应式布局一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验。参考：https://baike.baidu.com/item/响应式布局/1220833?fr=aladdin在网页中，我们通过 CSS媒体查询 来实现在不同的分辨率下，对页面整体或某些元素应用不同的样式，从而使页面在不同大小的设备上均有较好的用户体验。CSS的媒体查询是什么媒体查询是 CSS3 中添加的新功能。通过检查设备是否满足某些条件，来决定是否应用某些样式。参考：MDN如何使用Bootstrap来实现响应式布局在之前的例子中，我们页面中的列已经能够根据浏览器的大小自动调整自身的大小与位置了，那么是什么来决定列的变化临界点的？123&lt;div class="col-lg-4 col-md-3 col-xs-3"&gt;&lt;/div&gt;&lt;div class="col-lg-4 col-md-3 col-xs-12"&gt;&lt;/div&gt;&lt;div class="col-lg-4 col-md-6 col-xs-12"&gt;&lt;/div&gt;我们可以看到类名 col- 之后跟有 xs-、lg- 或 md-。这个就是决定这个列在多大的屏幕上应用这条样式的条件。可选的屏幕大小有 lg大屏、md中屏、sm小屏、xs超小屏（所有屏幕）。每种屏幕的分辨率大小临界值如下表所示。屏幕类型最小屏幕宽度超小屏幕0px小屏幕768px中等屏幕992px大屏幕1200px特别的，当我们应用超小屏幕列的类时，这个类会应用给所有分辨率，除非我们指定了更大屏幕的列的类。除了指定屏幕大小外，还跟有 3、4、6 或 12，这个数字则代表在这类屏幕下，这个列应该占用12网格中的多少格。因为是12网格系统，所以每一行最多展现12列。超出部分将自动换行。那么例子中的col-lg-4 col-md-3 col-xs-3则意味着这一列在大屏幕占用四个网格，中屏幕下占用三个网格，超小屏幕（所有屏幕）下占用三个网格。我们可以修改每一列所占用大小和屏幕类型，来体会网格系统带来的响应式布局效果。附录在本篇文章中，仅向大家介绍了 Bootstrap 框架的基础功能。在 Bootstrap 中还有更多漂亮方便的组件，例如 按钮、表单、相册框、媒体、自适应实用工具 等，各位可参考网上的官方文档继续学习 Bootstrap。参考文档Mozilla Developer Network(v4.0) Introduction - Bootstrap(v3.0) CSS - BootstrapBootstrap v3 菜鸟教程Bootstrap v4 菜鸟教程Bootstrap 可视化编辑器]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
        <tag>前端框架</tag>
        <tag>响应式布局</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础-安装与语法]]></title>
    <url>%2F2017%2F04%2F21%2FPHP%E5%9F%BA%E7%A1%80-%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[PHP与MySQL的安装下载XAMPP打开下载地址选择7.1.1 / PHP 7.1.1点击Download等待下载完成安装XAMPP运行下载的exe选择要安装的组件。建议全选。选择一个不包含空格的英文目录（比如D:\xampp）点击安装完成安装服务开始菜单-&gt;运行xampp control panel首次运行会弹出语言选择框。选英国国旗。点击Apache和MySQL前Service栏的红叉按钮，安装apache与mysql服务由于我未安装MySQL组件，所以MySQL这一栏为灰色不可用。点击Apache和MySQL的Start按钮，启动服务Module栏，Apache与MySQL字样的底色变绿表示服务启动成功，否则查看下方的日志安装完成浏览器中打开http://127.0.0.1/phpmyadmin出现phpMyAdmin页面，表示安装成功若出现页面无法访问，请检查xampp控制面板是否启动了apache与mysql服务。查看软件下方的日志来得到错误信息。Hello World这里我们写一个PHP的Hello World程序来了解PHP程序的运行方式。打开Sublime Text或其他代码编辑软件（不用使用记事本，因为会遇到UTF-8 Bom编码问题）。输入代码1234&lt;?phpecho("&lt;h2&gt;Hello World&lt;/h2&gt;");phpinfo();?&gt;保存文件至目录D:\xampp\htdocs，文件名为hello.php。其中D:\xampp为你安装xampp的目录。浏览器中打开http://127.0.0.1/hello.php若提示文件不存在，请检查你的文件名、保存路径和xampp控制台有无出错。由此可见，D:\xampp\htdocs为Apache网站服务器的根目录，之后调试程序都保存在此目录中。访问http://127.0.0.1/你的文件名 就可以运行你的PHP程序。PHP程序保存的文件后缀名必须是.php。从PHP程序输出的文本都是纯html，可以直接使用&lt;h2&gt;&lt;/h2&gt;这样的标签。PHP基础语法PHP的语法与C语言很像，又是弱类型的，所以上手起来很快。PHP标签所有的PHP代码都可以轻松地嵌入到HTML页面中。PHP程序必须写在&lt;?php ... ?&gt;组成的标签中。其中是各种PHP语句。对于代码中只有PHP语句的文件，?&gt;结束标签可以省略。12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;random&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;随机数：&lt;?=rand(0,100)?&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;保存至网站根目录中，到浏览器中打开。页面显示：1随机数：20这里使用了rand函数，参数为0与100。表示生成一个0-100范围内的随机数。这里使用了一种缩写语法，&lt;?=变量表列?&gt;等于&lt;?php echo 变量表列?&gt;这里的变量表列可以先当成一个变量名。为什么要叫表列会在后期介绍echo输出语言结构时解释。PHP变量PHP变量名以$为前缀，字母、下划线开头，由字母、数字、下划线组成例如 $1PHP 就是一个错误的变量名；$name、$col_name、$_list_1 这些则是正确的变量名。PHP语句PHP程序的基本单位是语句。语句必须由分号结尾。这个与C语言是一致的。123&lt;?php$name = "Alen虫";echo($name);浏览器中运行结果：1Alen虫这段程序作用是先初始化一个变量$name，赋值为&quot;Alen虫&quot;，随后输出变量$name。这段程序也在最后省略了?&gt;结束标签，因为文件内容是以php程序结尾。PHP注释PHP程序中的注释语法与C语言、JS等大部分语言一样，// 开头为单行注释，/* */ 包围多行注释PHP运算符PHP程序中有很多运算符。除了在其他语言中常见的加减乘除外，还有一些PHP自己的运算符。算术（数组）运算符：+、-、*、/三元运算符：? :赋值运算符：=、+=、-=、/=位运算符： &lt;&lt;、&gt;&gt;、^、&amp;、|、~逻辑运算符：||、&amp;&amp;、or、and、xor（异或）比较运算符：&lt;、&gt;、==、===、!=非运算符：!对象属性运算符：-&gt;字符串连接运算符：.instanceof运算符：instanceof执行运算符：``错误控制运算符：@这里罗列了常用的几种运算符，这些在C语言中也使用过。PHP所有的运算符使用说明请参阅PHP手册面向对象相关的运算符例如：对象属性运算符、instanceof运算符 在本章中暂不介绍，到学习面向对象时再一并介绍。这里仅介绍错误控制运算符、字符串连接运算符与执行运算符。错误控制运算符这个运算符能够使紧跟其后的第一个表达式不报错。123&lt;?phpecho $name;echo @$organization + 6;运行这段程序，页面输出16PHP Notice: Undefined variable: name in /usercode/file.php on line 2意思是说，文件第二行有一个提示性错误：name变量未定义。但第二个echo语句却被执行了，页面开头显示了6。因为有@错误控制运算符的存在，所以阻止了PHP报错：organization变量未定义。字符串连接运算符.英文句号就是字符串连接运算符。其作用是连接两个字符串。123&lt;?php$name = "My name is ";echo $name . "Alen虫";程序运行结果：1My name is Alen虫程序第二行通过.将变量$name与字符串Alen虫连接了起来，生成了新的字符串My name is Alen虫。执行运算符` ` 两个英文反引号就是执行运算符，表示在控制台运行命令并返回命令的输出。123&lt;?php$output = `dir /w`;echo "&lt;pre&gt;$output&lt;/pre&gt;";程序运行结果是输出了你的htdocs目录下的文件列表。php先去shell执行了dir /w命令，并将运行结果赋值给$output变量，随后输出。这里使用了双引号中的变量使用。在双引号的字符串中可以直接写$符号开头的来引用相关变量。]]></content>
      <categories>
        <category>PHP框架开发</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP框架开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面向对象程序设计基础]]></title>
    <url>%2F2017%2F04%2F12%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[1.数组：1.1数组的定义1)字面量定义1var arr = [1,2,3];2)对象定义（数组的构造函数）1&gt;var arr = new Array(参数);补：字面量固定的值，让你从“字面上”理解其含义。1.2数组的操作1)求数组的长度1数组的长度 = 数组名.length；2)获取数组中的元素1数组中的指定元素 = 数组名[索引值];1.3遍历数组（获取并操作数组中的每一个元素）（！！！重点！！！）1234var arr = [1,2,3];for(var i = 0;i&lt;arr.length;i++)&#123; arr[i] //如此操作数组中的每一个元素&#125;2调试（打断点）过去的调试（锻炼逻辑能力）alert(变量); console.log(变量);设置断点（项目太大，使用断点方便，清晰3.函数定义3.1函数声明（自定义声明）1234function f(a,b) &#123; return a + b; &#125;console.log(f(5,6));3.2函数表达式1234var myFun = function (a,b)&#123; return a + b; &#125; console.log(myFun(6,7));3.3函数声明和函数表达式的区别12345new: 1.开辟内存空间，存储新创建的对象（ new Object() ） 2.把this设置为当前对象 3.执行内部代码，设置对象属性和方法 4.返回新创建的对象12345678910111213函数声明 //此处的代码执行没有问题，JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面。 console.log(f(5,6)); function f(a,b) &#123; return a + b; &#125;函数表达式 //报错：myFun is not a function //这是为什么呢 myFun(6,7); var myFun = function (a,b)&#123; return a + b; &#125;3.4变量和作用域（隐式全局变量和变量声明提升）变量和作用域（函数中的变量需要函数执行后才能使用）一、全局变量（成员变量）哪里都可以访问到的变量。（进入script立即定义的变量和没有var的变量）二、局部变量函数内部的变量，只有函数内部可以访问到。（函数内部用var定义的变量和形参）参考:块级作用域在其它语言中，任何一对花括号中的语句都属于一个块，在这之中定义的所有变量在代码块外都是不可见的JavaScript中没有块级作用域全局变量定义在script或者不属于某个函数的变量局部变量定义在函数内部的变量其它函数内部可以访问到该函数所属的外部作用域的变量(作用域链)不使用var声明的变量是全局变量，不推荐使用。变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁3.5隐式全局变量123456789function fn（）&#123;var a = b = c = 1; // b和c就是隐式全局变量&#125;//注意:function fn（）&#123;var a = b = c = 1; // b和c就是隐式全局变量（等号）var a = 1; b = 2; c = 3; // b和c就是隐式全局变量（分号）var a = 1 , b = 2 , c = 3; // b和c就不是隐式全局变量（逗号）&#125;3.6变量声明提升（出现原因：预解析）函数中，定义变量在使用变量之后。值提升变量名，不提升变量值，容易出现undefined。计算后形成NaN。12345678910function fn()&#123;// var aaa;console.log(aaa);var aaa = 1;&#125;//提前看一眼这个习惯叫什么呢？ 预解析！//变量声明提升：在预解析的时候，成员变量和函数，被提升到最高位置，方便其他程序访问。//变量声明提升特点：成员变量只提升变量名，不提升变量值。但是，函数是所有内容全部提升。（function直接定义的）//函数范围内照样会出现变量声明提升//什么情况容易出现变量声明提升：使用变量在定义变量之前。变量提升定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。函数提升(稍后讲)JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面3.7小知识函数不调用不执行函数名就等于（整个函数）加载函数的时候，只加载函数名，不加载函数体参数相当于局部变量就近原则使用变量两个平级的函数中的变量不会相互影响（可以使用同样的形参名）4函数高级4.1匿名函数定义：匿名函数就是没有名字的函数。作用：不需要定义函数名的时候。（群众演员没必要起名，百万雄师下江南）书写起来更简便。匿名函数的调用有三种方法：一、直接调用或自调用。(function(){alert(1)})()二、事件绑定。三、定时器。123456匿名函数：没有命名的函数作用：一般用在绑定事件的时候语法function () &#123;&#125;自调用函数(function()&#123;alert("hello")&#125;)();4.2函数是一种类型（了解）函数作为方法的参数、函数作为方法的返回值都是可以的4.3函数作为参数（了解）什么是回调函数？简单理解就是函数做为参数。（这样的……）复杂理解：回调函数就是一个通过函数调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。123456789function dosomething(damsg, callback)&#123; alert(damsg); if(typeof callback == "function") callback(); &#125; dosomething("回调函数", function()&#123; alert("我是回调函数耶!"); &#125;);4.4递归（理解）递归：就是函数自己调用自己。（懂得）必须有跳出条件。什么是递归？方法自身调用，一般还要有结束的提交举例：从前有座庙，庙里有个老和尚5对象和面向对象什么是对象生活中的对象，一个车、一个手机对象具有特征和行为面向对象和基于对象面向对象：可以创建自定义的类型、很好的支持继承和多态。面向对象的语言c++/java/c#…面向对象的特征：封装、继承、多态万物皆对象：世间的一切事物都可以用对象来描述基于对象：无法创建自定义的类型、不能很好的支持继承和多态。基于对象的语言JavaScript部分 ！！！偏高级（可以看看热闹）！！！理解不了可不必理解！可不必理解！可不必理解！看清楚是：部分！！部分！！部分！！5.1JS中的对象（Object）12//创建空白对象var obj = new Object();5.2构造函数（就是为了创建对象实例）一、可以创建对象实例的函数。1) 区别与普通函数，首字母大写2) 构造函数并没有显式返回任何东西。new 操作符会自动创建给定的类型并返回他们，当调用构造函数时，new会自动创建this对象，且类型就是构造函数类型。1234function Person( name)&#123; this.name =name; &#125; var p1=new Person('John');等同于123456function person(name )&#123; Object obj =new Object(); obj.name =name; return obj; &#125; var p1= person("John");3) 因为构造函数也是函数，所以可以直接被调用，但是它的返回值为undefine，此时构造函数里面的this对象等于全局this对象。this.name其实就是创建一个全局的变量name。在严格模式下，当你不通过new调用Person构造函数会出现错误。4) 也可以在构造函数中用Object.defineProperty()方法来帮助我们初始化：12345678910111213function Person( name)&#123; Object.defineProperty(this, "name"&#123; get :function()&#123; return name; &#125;, set:function (newName)&#123; name =newName; &#125;, enumerable :true, //可枚举，默认为false configurable:true //可配置 &#125;); &#125; var p1=new Person('John');5) 在构造函数中使用原型对象1234//比直接在构造函数中写的效率要高的多 Person.prototype.sayName= function()&#123; console.log(this.name); &#125;;但是如果方法比较多的话，大多人会采用一种更简洁的方法：直接使用一个对象字面形式替换原型对象，如下：12345678Person.prototype =&#123; sayName :function()&#123; console.log(this.name); &#125;, toString :function()&#123; return "[Person "+ this.name+"]" ; &#125; &#125;;使用字面量形式改写了原型对象改变了构造函数的属性，因此他指向Object而不是Person。这是因为原型对象具有一个constructor属性，这是其他对象实例所没有的。当一个函数被创建时，它的prototype属性也被创建，且该原型对象的constructor属性指向该函数。当使用对象字面量形式改写原型对象时，其constructor属性将被置为泛用对象Object.为了避免这一点，需要在改写原型对象的时候手动重置constructor,如下：12345678910Person.prototype =&#123; constructor :Person, sayName :function()&#123; console.log(this.name); &#125;, toString :function()&#123; return "[Person "+ this.name+"]" ; &#125; &#125;;再次测试123456p1.constructor===Persontrue p1.constructor===Objectfalsep1 instanceof Persontrue5.3创建自定义对象1234This一、this只出现在函数中。二、谁调用函数，this就指的是谁。new People(); People中的this代指被创建的对象实例。6对象和面向对象26.1对象字面量个JSON12var obj = &#123;aaa: 111&#125;;var json = &#123;“aaa”:111&#125;;对象字面量定义方法和json很像，只有一点不同，json的key要求必须加“”;6.2Json组成var json = {“aaa”: 1,“bbb”: 2,“ccc”: 3,“ddd”: 4}Json由{}和key:value以及逗号组成，三部分。（只有一个键值对key:value时,可以没有逗号）6.3For…in…12345Var json = &#123;“aaa”: 1,“bbb”: 2,“ccc”: 3,“ddd”: 4&#125;for(var key in json)&#123;//key代表aaa,bbb.....等//json[key]代表1,2,3....等&#125;12345678910111213141516171819var obj = &#123; "key1":"value1", "key2":"value2", "key3":"value3"&#125;;function EnumaKey()&#123; for(var key in obj )&#123; alert(key); &#125;&#125;function EnumaVal()&#123; for(var key in obj )&#123; alert(obj[key]); &#125;&#125;EnumaKey(obj);//key1 key2 key3EnumaVal(obj);//value1 value2 value36.4构造函数复习12new Object()new后面调用函数，我们称为构造函数。Object() 我们把他视为一个构造函数，构造函数的本质就是一个函数，只不过构造函数的目的是为了创建新对象，为新对象进行初始化(设置对象的属性)6.5参数和传值问题一、简单类型数据做参数，函数内部对参数的修改不应影响外部变量简单类型传数值。二、复杂类型数据做参数，函数内部对参数的修改会应影响外部变量复杂类型传地址。6.6数组高级API学习API的方法侧重点（四点）调用者：谁调用的。参数：有无，几个。返回值：有无，什么类型。功能：干什么用的。自学方法：一、离线a)离线文档(群里有)二、在线W3C （前端标准W3CSchool）MDN （开发者网站）https://developer.mozilla.org/zh-CN/百度/谷歌/搜狗6.7Array的内置方法判断数组和转换数组:123456789101112Instanceof: 是一个关键字。 判断A是否是B类型。布尔类型值 = A Instanceof B ;Array.isArray() //HTML5中新增 判断是不是数组布尔类型值 = Array.isArray(变量) ;调用者：Array 参数：变量(被检测值) 返回值：布尔类型 toString() //把数组转换成字符串，每一项用,分割字符串 = 数组.toString();valueOf() //返回数组对象本身数组本身 = 数组.valueOf();Join //根据每个字符把数组元素连起来变成字符串字符串 = 数组.join(变量);变量可以有可以没有。不写默认用逗号分隔，无缝连接用空字符串。数组增删和换位置（原数组讲被修改）123456789101112131415161718192021push() //在数组最后面插入项，返回数组的长度数组1改后的长度 = 数组1.push(元素1);pop() //取出数组中的最后一项，返回最后一项被删除的元素 = 数组1.pop();unshift() //在数组最前面插入项，返回数组的长度数组1改后的长度 = 数组1.unshift(元素1);shift() //取出数组中的第一个元素，返回最后一项被删除的元素 = 数组1.shift();reverse() //翻转数组（原数组讲呗反转，返回值也是被反转后的数组）反转后的数组 = 数组1.reverse();sort(); //给数组排序，返回排序后的数组。如何排序看参数。从小到大排序后的数组 = 数组1.sort(function(a,b)&#123; return a-b;&#125;);`无参：按照数组元素的首字符对应的Unicode编码值从小到大排列数组元素。带参：必须为函数（回调函数--callback）。函数中带有两个参数，代表数组中的 前后元素。如果计算后（a-b），返回值为负数，a排b前面。等于0不动。 返回值为正数，a排b后面。`了解方法12345678910111213141516171819202122232425262728293031323334353637concat() //把参数拼接到当前数组新数组 = 数组1.concat(数组2);slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始新数组 = 数组1.slice(索引1，索引2);splice()//删除或替换当前数组的某些项目，参数start,deleteCount,options(要替换的项目)新数组 = 数组1.splice(起始索引，结束索引，替换内容);indexOf()、lastIndexOf() //如果没找到返回-1索引值 = 数组.indexOf/lastIndexOf(数组中的元素);迭代方法 不会修改原数组every()、filter()、forEach()、map()、some()数组/boolean/无 = 数组.every/filter/forEach/map/some( function(element,index,arr)&#123; 程序和返回值； &#125;);//对数组中每一项运行以下函数，如果都返回true，every返回true，如果有一项返回false，则停止遍历 every返回false；不写默认返回falsearray.every(function(item,index,arr) &#123;&#125;)//对数组中每一项运行以下函数，该函数返回结果是true的项组成的新数组var arr = array.filter(function(item,index,arr) &#123;&#125;);console.log(arr); //遍历数组array.forEach(function(item,index,arr)&#123;&#125;);//对数组中每一项运行以下函数，返回该函数的结果组成的新数组var arr = array.map(function(item,index,arr) &#123; return "\"" + item + "\"";&#125;)//对数组中每一项运行以下函数，如果该函数对某一项返回true，则some返回truevar b = array.some(function(item,index,arr) &#123; if (item == "ww") &#123; return true; &#125; return false;&#125;);]]></content>
      <categories>
        <category>精通JS开发教程</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>JS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP框架开发-第四讲 PHP魔术方法与配置管理模块的开发]]></title>
    <url>%2F2017%2F04%2F07%2FPHP%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-%E7%AC%AC%E5%9B%9B%E8%AE%B2%20PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[PHP的魔术常量与魔术方法PHP自带了很多魔术方法与魔术常量。这些魔术方法与魔术常量可以实现动态地定义属性或方法。这种动态机制也叫重载。PHP中的”重载”与其它绝大多数面向对象语言不同。传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。当调用当前环境下未定义或不可见的类属性或方法时，类中的重载方法会被调用。所有的魔术常量与方法都是以__（两根下划线）开头。所以自己在编写代码时，不要以__双下划线开头。魔术方法PHP提供的魔术方法有：__construct() 构造函数__destruct() 析构函数__call() 方法调用函数__callStatic() 静态方法调用函数__get() 属性调用函数__set() 属性设置函数__isset() 属性或方法的isset检查函数__unset() 属性或方法的unset释放函数__sleep() 序列化函数__wakeup() 反序列化函数__toString() 转字符串__invoke() 模拟函数调用__set_state() var_export导出函数__clone() clone复制函数__debugInfo() var_dump调试导出函数这里只介绍前六个常用的魔术方法，其他方法请参阅PHP手册-魔术方法魔术常量PHP中的常量大部分都是不变的，但是有8个常量会随着他们所在代码位置的变化而变化，这8个常量被称为魔术常量。魔术常量总是以双下划线开头，双下划线结尾的全大写英文。PHP提供的魔术常量有：__LINE__ 文件中的当前行号。__FILE__ 当前文件的完整路径和文件名。__DIR__ 当前文件所在的目录。__FUNCTION__ 当前函数名称__CLASS__ 当前类的名称__TRAIT__ Trait 的名字__METHOD__ 当前方法名__NAMESPACE__ 当前命名空间的名称常用的魔术方法所有魔术方法的可见度都必须被声明为public。__construct()类在被new实例化时，如果定义了__construct()构造函数，则会立即执行__construct()方法。12345678&lt;?phpclass A&#123; public function __construct()&#123; echo(__CLASS__); &#125;&#125;$t = new A; //程序输出：A这里的__CLASS__就是一个魔术常量，值是当前类名A当然，构造函数也可以接受参数。1234567891011&lt;?phpclass A&#123; protected $name; public function __construct($name)&#123; $this-&gt;name = $name; echo(__METHOD__ . $this-&gt;name); &#125;&#125;$t = new A; //报错：__construct函数缺少一个必须参数。$t = new A("君の名は"); //程序输出：A::__construct君の名は这里的__METHOD__魔术常量的值是包含类名的方法名。构造函数是PHP面向对象中举足轻重的技术。在后期开发时几乎每个小模块都需要用到构造函数。__destruct()程序都有生命周期，类也是。在类被销毁时，无论以哪种方式，只要定义了__destruct()析构函数，它就会被执行。123456789&lt;?phpclass A&#123; public function __destruct()&#123; echo(__CLASS__." has been destroyed"); &#125;&#125;$t = new A;程序输出：A has been destroyed你们会问，程序中只有new A实例化语句，没有销毁命令，为什么类被销毁了？因为执行到实例化语句后，没有更多的代码了，所以主程序执行完毕。在退出前，PHP会进行内存清理，这时会释放所有被实例化的对象。这样就触发了对象的__destruct()函数。手工释放对象：1234567891011&lt;?phpclass A&#123; public function __destruct()&#123; echo(__CLASS__." has been destroyed"); &#125;&#125;$t = new A;unset($t);echo(123);程序输出：A has been destroyed123由于$t变量被注销，所以对象被析构，触发了destruct()函数。之后程序执行了echo(123)语句，输出了123。__call()当尝试调用对象实例中不可访问的方法时，会触发__call()方法，传入的参数是访问的方法名。123456789101112&lt;?php&lt;?phpclass A &#123; public function __call($name,$param)&#123; var_dump($name,$param); &#125;&#125;$t = new A;$t-&gt;test(123);$t-&gt;test2();程序输出：123456789101112131415string(4) "test"array(1) &#123; [0]=&gt; int(123)&#125;string(4) "test"array(2) &#123; [0]=&gt; int(123) [1]=&gt; string(15) "第二个参数"&#125;string(5) "test2"array(0) &#123;&#125;__call()方法接受两个参数。第一个是访问的函数名（test），第二个是传入的参数列表数组（[123]）。若没有调用的参数，则参数列表数组是一个空数组（[]）。__callStatic()__call()方法只能处理被实例化的对象方法调用问题，对于静态访问的对象方法就要用__callStatic()来处理了。它的用法与__call()类似，只不过只能处理静态放问。12345678910111213&lt;?phpclass A&#123; public function __call($name, $param)&#123; var_dump("用__call处理了方法：&#123;$name&#125;"); &#125; public static function __callStatic($name, $param)&#123; var_dump("用__callStatic处理了方法：&#123;$name&#125;"); &#125;&#125;$t = new A;$t-&gt;test(123);A::test();程序输出：12string(31) "用__call处理了方法：test"string(37) "用__callStatic处理了方法：test"这里值得注意的是，由于__callStatic()方法只能处理静态方法，所以其本身也必须被声明为静态类型。12345class A&#123; public function __callStatic($name, $param)&#123; var_dump("用__callStatic处理了方法：&#123;$name&#125;"); &#125;&#125;程序报错：魔术方法__callStatic()必须有public可见度，并且是静态的。__get()当尝试访问类中不可访问的属性时，会调用__get()方法。12345678&lt;?phpclass A&#123; public function __get($name)&#123; return ("访问了".$name); &#125;&#125;$t = new A;echo $t-&gt;test;;程序输出：访问了test__get()方法接受一个参数，传入的值为被访问的属性名。当然，其也要有一个返回值，返回被访问的属性值。当然，如果被访问的属性确实不存在，那么我们可以在__get()方法中抛出错误。12345678910111213&lt;?phpclass A &#123; protected $arr = ["name"=&gt;123]; public function __get($name) &#123; if(!key_exists($name, $this-&gt;arr)) throw new Exception("$name 不存在"); return $this-&gt;arr[$name]; &#125;&#125;$t = new A;var_dump($t-&gt;name);var_dump($t-&gt;test);程序报错：未捕获的异常&#39;Exception&#39;，消息&#39;test 不存在&#39;。注释最后一行代码，程序则输出：123。即使定义了__get()方法，也不能使用静态操作访问不可访问的静态属性。__set()在尝试修改不可访问的属性值时，会调用__set()方法。其接受两个参数，第一是属性名，第二是属性值。1234567891011121314&lt;?phpclass A &#123; protected $arr = ["name"=&gt;123]; public function __set($name, $value) &#123; if(!key_exists($name, $this-&gt;arr)) throw new Exception("$name 不存在");$this-&gt;arr[$name] = $value; return true; &#125;&#125;$t = new A;var_dump($t-&gt;test=789);var_dump($t-&gt;name=456);程序报错：未捕获的异常&#39;Exception&#39;，消息&#39;test 不存在&#39;。注释掉倒数第二行语句，程序输出int(456)。配置管理模块的开发123456789101112131415161718192021class Config&#123; protected $config = []; public function __construct($config = []) &#123; //在new实例化Config类时，接受一个数组，表示一个简单的配置数组 $this-&gt;config = (array)$config; &#125; public function __get($name) &#123; if (!key_exists($name, $this-&gt;config)) return null;//配置项不存在，则返回null空 return $this-&gt;config[$name];//配置项存在，则返回值 &#125; public function __set($name, $value) &#123; return $this-&gt;config[$name] = $value;//设置配置 &#125;&#125;通过这个Config类，我们可以实现用面向对象的操作来访问配置数组。例如123456789101112&lt;?php$config = [ 'host' =&gt; "127.0.0.1", 'username' =&gt; 'root' 'password' =&gt; ''];$config = new Config($config);echo $config-&gt;host; //输出 127.0.0.1echo $config-&gt;username; //输出 rootecho $config-&gt;password; //输出空echo $config-&gt;test_null; //输出空当然，这样的Config类是不完善的。等到框架大致开发完毕时，我们再来探讨怎么样来优化。]]></content>
      <categories>
        <category>PHP框架开发</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP框架开发</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP框架开发-第三讲 面向对象trait与路由器实现原理]]></title>
    <url>%2F2017%2F03%2F24%2FPHP%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-%E7%AC%AC%E4%B8%89%E8%AE%B2%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1trait%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[面向对象之traitPHP是一门单继承的面向对象语言。也就是说，一个类只能有一个直接的爸爸。例如123456&lt;?phpclass A &#123;&#125;class B extends A &#123;&#125;class C extends A,B &#123;&#125; //报错：遇到意外的 , ，期望遇到 &#123;。多继承是指 一个类可以用有多个爸爸。例如 A extends B, C 这样。但在这种情况下，会使一个类的结构变得复杂，也很难判断一个类是不是属于某个爸爸。然而，在这样的情况下，我怎样实现 A 与 B 共有代码呢？trait 定义如同普通的类一样，可以通过 trait 关键字来定义trait。12345678910&lt;?phptrait common&#123; public function update() &#123; echo("执行了".__CLASS__."中的".__METHOD__."方法"); &#125; public function name() &#123; echo $this-&gt;name; &#125;&#125;注：在PHP中，双下划线包围的标识符通常是魔术常量。代码中的 __CLASS__表示当前对象的类名，而__METHOD__则表示当前方法名。PHP中还有很多魔术方法和魔术常量，这个在之后会慢慢讲到。使用trait123456789&lt;?phpclass Pet &#123; protected $name = "George"; use common;&#125;$my_pet = new Pet();$my_pet-&gt;name();//输出：George$my_pet-&gt;update();//输出：执行了Pet中的common::update方法注：trait与class一样，也是有命名空间概念的。在use的时候，注意当前类与trait是不是在同一个命名空间中。实例1234567891011121314151617181920212223242526272829&lt;?phptrait computer &#123; public function code() &#123; echo("我能写代码"); &#125; public function query() &#123; echo("我能查资料"); &#125;&#125;class Human &#123; use computer;//人类使用了computer，所以人可以写代码，查资料&#125;class Cat&#123;//猫没使用computer，所以猫不会写代码，不会查资料&#125;$dog = new Human;$dog-&gt;code();$dog-&gt;query();$cat = new Cat();$cat-&gt;code();//报错：code未定义$cat-&gt;query();//报错：query未定义现实中的路由器再大的互联网，也是由一个个小局域网组成的。每个局域网中至少包含一个路由器和n台主机。我们传统意识中，路由器的作用是让我们上网。这个只是表象。也许老师教过我们192.168.0.1这个地址中，192.168.0是网络地址，而最后的1是主机地址。其实这是错误的。主机地址和网络地址的范围是根据子网掩码来确定的。这个就是路由器对ip地址与子网掩码地址进行二进制位操作得到的结果来确定的。当然，以前老师也告诉过我们，网络地址不同的主机之间，是不能够相互访问的。其实这也是错误的。应该说是不能直接访问。借助路由器的路由表，就可以使不同网络的机器相互访问。路由器会根据路由表中目标网络地址的路由器在当前网络中的地址，来转发数据包。这样就实现了不同网络间的主机互访。我们框架中的路由器就是实现一个类似的功能。只不过是把url地址，通过一定的规则（路由表），解析成要访问的控制器、方法。框架路由器执行流程路由器实现HTTP请求方法HTTP请求分为好几种方法，不同的方法有不同的使用场景。正常访问网站使用GET方法；像注册、登录、提交问卷等场景则使用POST方法。这两种是常用的请求方法。但对于一些高级的系统来说，还会用到其他方法。例如DELETE方法用来删除指定资源，HEAD方法用来得到请求头等。我们的路由器后期会扩展成分方法绑定地址的规则。也就是说只有方法匹配的请求才会被正确调度。例如，我绑定了get操作，访问地址是User/index，控制器是UserController@index，那么如果我用POST方法提交给User/index地址时，路由器会抛出错误：地址不存在。路由表定义机制这里使用一个简化的路由表分析算法。我们默认一个规则，也是常用于ThinkPHP框架的路由规则：访问地址为控制器/方法名。也就是说，用户访问地址是 http://127.0.0.1/User/index时，路由器会调度到User控制器的index方法。路由器实现1234567891011121314151617181920212223242526&lt;?phpclass Router&#123; const DEFAULT_CONTROLLER = "Home";//预定义一个常量，表示默认控制器为Home const DEFAULT_ACTION = "index";//预定义一个常量，表示默认操作index public static function getUrl()&#123; return $_SERVER['PHP_SELF'];//得到访问的路径，即：/User/index这部分 &#125; /** * 路由规则：控制器名/操作名/额外参数 **/ public static function parseUri($uri)&#123; $uri = (array)explode("/", $uri);//把拿到的URI以"/"为分隔符展开成数组，即使不是数组也会被强制转换成Array。 $result = [];//创建一个用来保存结果的 $result['controller'] = ucfirst(array_shift($uri)) ? : static::DEFAULT_CONTROLLER;//拿到“/”前的第一个字符串，将首字母大写并保存到controller索引中。如果拿到的值为空，则使用预定义的默认控制器名称。 $result['action'] = array_shift($uri) ? : static::DEFAULT_ACTION;//得到“/”后的第一个字符串，并保存到action索引中。如果拿到的值为空，则使用预定义的默认操作名称。 $result['param'] = $uri;//将剩下的数据保存到param索引中，作为额外的访问参数 return $result;//将解析结果返回 &#125; public static function handle()&#123; $dispatch = static::parseUri(static::getUri());//通过之前定义的两个方法来得到调度结果 return $dispatch;//返回调度结果 &#125;&#125;一个简单的Router路由器就这样完成了。等到PHP熟练之后，可以加上定义路由表的功能。由于目前各位刚起步，所以就不为难大家了。路由器测试新建一个PHP文件，名字为index.php。保存到网站根目录。123&lt;?phpinclude("Router.php");var_dump(Router::handle());浏览器访问http://127.0.0.1，页面输出：12345array(3) &#123; "controller" =&gt; "Home", "action" =&gt; "index", "param" =&gt; []&#125;start=>start: 开始 bind_url=>subroutine: 绑定路由规则至路由表 input_url=>inputoutput: 输入URL地址 scan_table=>operation: 扫描路由表 rule_exists=>condition: 路由规则是否存在 throw_error=>operation: 抛出错误：页面不存在 dispatch=>inputoutput: 生成匹配结果并返回 end=>end: 结束 start->input_url->scan_table->rule_exists rule_exists(yes)->dispatch->end rule_exists(no)->throw_error->end start->bind_url bind_url(left)->input_url bind_url(right)->input_url{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)]]></content>
      <categories>
        <category>PHP框架开发</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP框架开发</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP框架开发-第二讲 PHP面向对象]]></title>
    <url>%2F2017%2F03%2F17%2FPHP%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-%E7%AC%AC%E4%BA%8C%E8%AE%B2%20PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[面向对象的编程理念是世间万物都为对象。面向对象的基础是类。面向过程与面向对象上一讲开头出现的那段代码，就是面向过程编程。它讲究编程中的细节。例如保存SQL、保存查询结果、执行查询、变量赋值、输出结果等操作。C语言就是典型的面向过程语言。而面向对象则讲究程序的架构，又可以说是程序模块的客观规律，或者是小功能的代码集合。举个现实中的例子，人是一个对象。人可以走、跑跳、打架、说话、写代码……。而做菜就是面向过程，先让人拿锅子、拿原料、点火、倒油、放原料……在面向对象中，必然包括面向过程。面向对象的好处与缺点使用面向对象方法来做开发，能实现代码复用。同时，可以让程序结构更清晰，易于维护，便于在后期进行扩展开发，增加程序功能。但是，使用面向对象思想来开发程序会延长开发周期。而面向过程能更快地实现功能，开发效率比面向对象高。在实际开发中，两种思想相辅相成。对于简单的小程序，甚至可以不需要面向对象。所以，面向对象与面向过程之间，没有孰优孰劣之分。没有最好的，只有最合适的。类与对象的区别类是现实生活中的一个物种，而对象则是这个物种的具体动物。 例如，人类 是类，爸爸是对象，狗是类，家里的宠物狗是对象。对象是类的一个实例。PHP面向对象的历史PHP刚诞生的时候，是不支持面向对象的。那时候如果要用PHP开发模块化程序，就要把不同的功能、模块程序写在不同的文件中。index.php或其它入口程序就要灵活地使用require()、include()函数，在需要使用对应模块的地方引用其他php程序。自从PHP升级到5.0之后，开始慢慢支持面向对象。直到PHP5.4，其已经有较完善的面向对象语法。同时，它还进化出了自己独有的代码复用结构。面向对象的相关语言结构PHP提供了丰富的面向对象方法。整理起来，有如下结构：定义 class公开 public私有 private保护 protected友好访问属性 var命名空间 namespace实例化 new静态 static继承 extends抽象类 abstract最终类 final接口定义 interface接口实现 implement代码碎片 trait引用代码 use…(as)…(instead of)…鉴于内容太多，本章中就先介绍前7个基本结构。class 定义类使用class能定义一个类。作为创世主的你可以随意创造一个物种。例如创造一个Dog物种。123456789&lt;?phpclass Dog &#123; public function bark() &#123; echo "I barked."; &#125;&#125;$pet = new Dog();$pet-&gt;bark();程序输出 I barked.代码中我先定义了一个类，名字叫Dog。它有一个公开方法bark。然后，实例Dog类，赋值给变量$pet。调用$pet对象的公开方法bark()。public、private、protected与var每个人都会有属于自己的小秘密，当然也有只给部分朋友看的半公开秘密，剩下的就是完全对外展示的特质。在面向对象中，这四个关键字就是用来体现这种属性与方法的公开程度。privateprivate 私有方法最小气，只允许自己访问。12345678910111213141516171819&lt;?phpclass Cat &#123; private $heart = "warm"; private function smile() &#123; echo $this-&gt;heart; &#125; public function eat() &#123; $this-&gt;smile(); &#125;&#125;$cat = new Cat();$cat-&gt;smile();//报错：致命错误(Fatal Error)：尝试执行了一个私有方法smile。$cat-&gt;eat();//运行正常，输出warmecho $cat-&gt;heart;//报错：致命错误：尝试访问私有变量。varvar 则是用来定义一个局部访问属性，并且只能用来定义属性。它表示这个属性能给当前文件访问。类中定义方法时，若直接写function，不加修饰符，则也表示这种局部访问范围。在JAVA中，这种局部访问范围也叫friendly。protectedprotected 保护是用来表示这个属性或方法只能给自己、儿子、孙子等自己的派生类访问。就像家族遗传一样，爸爸的东西，也是儿子的东西。所谓的儿子就是当前类的派生类，即使用extends直接或间接继承了当前类的类。参阅本章extends节。publicpublic 最慷慨，表示这个属性或方法能给所有人访问。namespace 命名空间namespace 命名空间是程序的文件夹，表示程序在哪个文件夹中。只有相同命名空间的程序之间，才能相互访问。不同命名空间的程序要想互访，就需要在实例化时写全命名空间，或者在开头使用use引入其他命名空间的程序。文件a.php12345namespace utils;class A &#123; var $name = 123;&#125;文件b.php1234567891011121314151617&lt;?phpinclude "a.php";namespace system\utils;class B &#123; var $name = 456; public function execute()&#123; $a = new \utils\A(); //程序运行正常 $a = new utils\A(); //程序报错：类 system\utils\utils\A 不存在 $a = new A(); //程序报错：类 system\utils\A 不存在 &#125;&#125;$b = new B;$b-&gt;execute();由此可见，命名空间也会有相对路径这一说法。要想从根命名空间开始引用，一定要在开头写反斜杠。实例化通常，程序中，若要使用类，就必须把类实例化成对象。123456789&lt;?phpclass human &#123; public function talk($word) &#123; echo $word; &#125;&#125;$man = new human();$man-&gt;talk("社长最帅");new 可以实例化一个类。静态通常，类是需要被实例化之后才能使用的。但有时候，我只想使用类中的一个常量、变量或方法。这个时候，就需要使用 static 静态属性方法了。123456789101112131415&lt;?phpclass Cat &#123; const NAME = "stephen";//常量 public static $age = 11; public static function age()&#123; self::$age++; &#125;&#125;echo Cat::$age;Cat::age();echo Cat::$age;Cat::age();echo Cat::$age;var_dump(Cat::NAME);程序运行结果：111213string(7) &quot;stephen&quot;由此可见，静态属性或方法，还有常量，可以在类没有被实例化时直接访问。当然，实例化后进行访问也可以，只是需要使用::操作符。继承继承是代码复用的一种体现。子代类可以拥有父代类所有的属性、方法，同时它还能扩展、重载父代中原有的方法。子代类可以通过parent关键字来访问父代的常量、属性、方法与当前方法。123456789101112131415161718&lt;?phpclass A &#123; protected $name = "common"; public function eat()&#123; echo ("A eat&lt;br&gt;"); &#125;&#125;class B extends A &#123; public function eat()&#123; echo ("B eat.&lt;br&gt;") . $this-&gt;name; parent::eat(); &#125;&#125;$b = new B();$b-&gt;eat();]]></content>
      <categories>
        <category>PHP框架开发</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP框架开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP框架开发-第一讲 PHP框架导论]]></title>
    <url>%2F2017%2F03%2F10%2FPHP%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-%E7%AC%AC%E4%B8%80%E8%AE%B2%20PHP%E6%A1%86%E6%9E%B6%E5%AF%BC%E8%AE%BA.html</url>
    <content type="text"><![CDATA[何为PHP框架PHP框架是一套集成了数据库操作模块、URL路由模块、浏览器请求模块等各种常用代码的PHP程序集。为何使用PHP框架开发网站PHP框架中集成了我们开发网站所需的大部分代码，例如：数据库操作、文件访问、请求分析、MVC引擎等。我们可以直接使用框架中提供的函数、对象、方法等来实现快速我们的网站，为我们省下了开发基础功能的时间。常见的PHP框架laravelYiiThinkPHPCodeIgniterSymfony…Yii这个框架使用者逐年下降，它的开发方法太繁琐了，前端和后端捆绑过于紧密，我不推荐用。但可以学习它的实现思路。MVC简介MVC起源初学者常见的网站开发流程大部分初学者都喜欢在页面中编写PHP语句。例如在MySQL数据库中有数据表useriduserpassword1alen1234562root123456现要在一张网页中展示这张数据表。编写代码如下123456789101112131415161718192021222324252627282930&lt;table&gt; &lt;tr&gt; &lt;th&gt;uid&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;/tr&gt; &lt;?php $db_link = require("db.php");//引入数据库连接，并得到连接ID $sql = "SELECT * FROM user;";//这是一条从user数据表中获取所有行的SQL语句 $query = mysqli_query($db_link, $sql);//执行SQL语句，返回结果集 if(!$query) die("数据库连接失败");//查询失败，程序结束 while($row = mysqli_fetch_assoc($query))&#123;//循环结果集，得到每一行数据 ?&gt; &lt;tr&gt; &lt;td&gt; &lt;?=$row['id']?&gt; &lt;/td&gt; &lt;td&gt; &lt;?=$row['name']?&gt; &lt;/td&gt; &lt;td&gt; &lt;?=$row['password']?&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; mysqli_free_result($query);//释放结果集 mysqli_close($db_link);//释放连接 ?&gt;&lt;/table&gt;mysqli_query函数用来在$db_link数据库中指定执行SQL语句mysqli_fetch_assoc函数用来从$query查询结果中取出结果数组结果数组 是查询得到的结果集中的一列数组。数组元素的索引名是数据表的字段名mysqli_free_result 函数用来从内存中释放查询得到的结果集mysqli_close 函数用来关闭数据库连接，释放连接资源这段程序运行起来没有问题，但如果有很多数据需要展示的话，就需要写很多这样的代码。而且，如果有一天我需要大幅度更换页面样式了，由于代码中数据库操作部分的代码与页面html交杂在一起，导致整张页面都需要重写，最终导致的就是可维护性差。问题的解决方法就是使数据库操作代码与HTML页面展示代码分开。MVC定义使业务逻辑（也就是数据库操作、数据判断等代码）与页面代码（HTML）分开开发的软件开发模式叫MVC。其中，M指模型（Model），V指视图（View），C指控制器（Controller）。网站开发中的MVC在网站开发中，模型通常用来操作数据库与实现数据判断逻辑；控制器则用来处理用户提交的表单并把数据提交给模型，并把处理结果返回给视图；视图则是一张成型的HTML网页，只不过挖去了数据部分。PHP中的MVC在PHP中，一个小模块对应一个控制器类，其中有实现各种操作的方法，例如修改用户、新增博客文章、删除评论、展示首页等等。小模块例如：用户中心、博客、首页、留言板等。而Model，则是一张数据表对应一个模型类s，模型名是数据表名。例如上文中的user数据表，其模型名就是User。每个模型共用的add、update、delete、get方法，即对数据库的增删改查操作由框架实现。框架提供一个Model类，其使用框架的方法，实现了增删改查操作，每个模型类继承这个类。View，是一个HTML页面模板，其中有写好的页面样式。通常是一个控制器的一个操作方法对应一个视图模板。通常视图会由视图模板引擎来渲染输出到浏览器MVC扩展对于一些大型网站系统来说，Model模型会被细分为Service服务层、Logic逻辑层与Model数据模型层。此时，Model模型层就只负责操作数据库，例如增删改查，业务逻辑代码则被放置在了Logic逻辑层中。而Service服务层，则用来存放多个模块公用的代码。例如一套网站系统的用户系统、文件系统。网站的前台和后台都需要操作用户系统与文件系统。这两套系统同时为网站的前台与后台服务，所以这一层叫服务层。当然，MVC架构很灵活，可以任意变动。对于小网站来说，甚至可以不需要Model模型层，只留下Controller与View。业务逻辑代码在Controller中实现。PHP框架运行流程URL调度对于地址：http://admin.djwebclub.com/Admin/Signup/index.htmlURL构成协议://主机名:端口号/资源路径在http协议中，端口号默认为80框架先把地址拆开，得到数组12345678$url = [ 'scheme' =&gt; "http", //协议 'host' =&gt; "admin.djwebclub.com", //主机名 "path" =&gt; "/Admin/Signup/index.html", //资源地址 "port" =&gt; 80, //端口号 "filename" =&gt; "index.html", //文件名 "basename" =&gt; "index" //文件主名称];ThinkPHP路由规则：/模块名/控制器名/操作名.html框架根据路由规则进行URL调度，结果为php $dispatch = [ &#39;module&#39; =&gt; &quot;Admin&quot;, &#39;controller&#39; =&gt; &quot;Signup&quot;, &#39;action&#39; =&gt; &quot;index&quot;, ];st=>start: 开始 e=>end: 发布 db=>operation: 编写数据库连接代码 home_page=>operation: 编写首页 about_page=>operation: 编写介绍自己页 blog_page=>operation: 编写博客页 other_page=>operation: 编写其他页面 debug=>condition: 调试网站 st->db->home_page->about_page->blog_page->other_page->debug debug(yes)->e debug(no)->db{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)st=>start: 启动程序 e=>end: 运行结束 load1=>inputoutput: 载入框架的一些核心PHP程序文件 load2=>inputoutput: 载入网站配置文件，通常是config.php load3=>inputoutput: 根据配置文件，初始化系统 dispatch1=>inputoutput: 读取访问URL，即浏览器地址栏中的URL地址 dispatch2=>operation: 解析URL，得到访问的目标控制器与操作方法 dispatch3=>condition: 寻找控制类与操作方法是否存在 error=>operation: 调度失败，显示错误页面 dispatch4=>operation: 调度成功，实例化控制器类，并执行操作方法 result=>operation: 根据执行结果，载入相应的视图文件 view=>operation: 渲染并显示视图文件 return=>operation: 向客户端返回请求（可选） st->load1->load2->load3->dispatch1->dispatch2->dispatch3 dispatch3(yes)->dispatch4 dispatch3(no)->error dispatch4->result->view->return->e error->return{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-1-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-1",options)]]></content>
      <categories>
        <category>PHP框架开发</category>
      </categories>
      <tags>
        <tag>谈技术</tag>
        <tag>PHP框架开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础教程-第二讲]]></title>
    <url>%2F2017%2F02%2F27%2FHTML%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E8%AE%B2.html</url>
    <content type="text"><![CDATA[HTML5的新特性用于绘画的 canvas 元素用于媒介回放的 video 和 audio 元素对本地离线存储的更好的支持新的特殊内容元素： article、footer、header、nav、section新的表单控件：calendar、time、email、url、search、range、tel、color……CSS概述CSS指层叠样式表（Cascading Style Sheets）样式定义了如何显示HTML元素把样式添加到HTML中，是为了解决内容与表现分离的问题外部样式表通常存储在CSS文件中多个样式可层叠为一个样式层叠根据元素的CSS样式定义的位置，可将CSS分为浏览器缺省设置外部CSS内部样式表内联样式其中，CSS规则的优先级为4&gt;3&gt;2&gt;1内联CSS具有最高的优先级内联CSS所谓的内联CSS，是指在HTML标签内定义的CSS样式比如1&lt;input type="button" style="background: #FFF;"&gt;style 属性是内联样式属性background 是CSS属性名，表示元素背景#FFF 是CSS属性值，表示16进制白色background: #FFF; 构成一条CSS声明，声明必须以分号结尾九个CSS属性color 文字颜色语法color: 颜色 ;12&lt;p style="color: red;"&gt;我的颜色是红色&lt;/p&gt;&lt;h1 style="color: red;"&gt;我是红色的标题&lt;/h1&gt;font-size 字号语法font-size: 字号 ;123&lt;h1 style="font-size: 14px;"&gt; 我是一号标题，但是我的字很小&lt;/h1&gt;font-family 字体语法font-family: 字体1名称 [,字体2名称 [,字体3名称…… ;123&lt;h1 style="font-family: '微软雅黑';"&gt; 我的字体与众不同&lt;/h1&gt;text-align 文字对齐语法text-align: left|center|right ;123456789&lt;p style="text-align: right;"&gt; 我向右对齐&lt;/p&gt;&lt;p style="text-align: left;"&gt; 我向左对齐&lt;/p&gt;&lt;p style="text-align: center;"&gt; 我居中对齐&lt;/p&gt;background 背景语法background: 颜色 url(‘图片地址’) 图片位置/背景大小;123&lt;p style="background: red;"&gt; 我的背景是红色的&lt;/p&gt;width 宽度语法width: 宽度大小 ;123&lt;p style="width: 100px;background: red;"&gt; 我的宽度只有100像素&lt;/p&gt;height 高度语法height: 高度大小 ;123&lt;p style="height: 100px;background: red;"&gt; 我的高度只有100像素&lt;/p&gt;box-shadow 盒子阴影语法box-shadow: 水平偏移量 垂直偏移量 模糊距离 [阴影大小] 阴影颜色 ;123&lt;p style="box-shadow:10px 10px 5px 5px #F00;"&gt; 我的外框会发出红色的阴影&lt;/p&gt;text-shadow 文字阴影语法text-shadow: 水平偏移量 垂直偏移量 模糊距离 阴影颜色 ;123&lt;p style="text-shadow:10px 10px 5px #F00;"&gt; 我的字会发出红色的阴影&lt;/p&gt;]]></content>
      <categories>
        <category>HTML基础教程</category>
      </categories>
      <tags>
        <tag>HTML基础教程</tag>
        <tag>谈技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础教程-第一讲]]></title>
    <url>%2F2017%2F02%2F16%2FHTML%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E8%AE%B2.html</url>
    <content type="text"><![CDATA[HTML概念HTML全称：Hyper Text Markup Language中文：超文本标记语言注：HTML并非编程语言，而是一种标记语言（标记语言是一套标记标签）HTML标签HTML的标签是由&lt;&gt;包围的关键字，通常是成对出现的（例如：&lt;html&gt;&lt;/html&gt;）但也有特殊情况（单标签）（例如：&lt;input&gt; &lt;img&gt; &lt;link&gt;）标签中的第一个标签成为开始标签（也称开放标签），第二个标签是结束标签（也称闭合标签）HTML文档定义HTML文档是用来描述网页的HTML文档包含HTML标签和纯文本HTML文档也被成为网页注：Web浏览器的作用是读取HTML文档并以网页的形式显示出它们，Web浏览器不会显HTML标签，而是使用标签来解释页面的内容。文档结构1234567891011&lt;!DOCTYPE html&gt;----------------声明&lt;html&gt;-------------------------&lt;html&gt;&lt;/html&gt;作为固定搭配，用来包裹页面。&lt;head&gt;-------------------------head标签一般放非可视化标签 &lt;meta charset="utf-8"&gt;------编码方式为”utf-8”,避免乱码 &lt;title&gt;&lt;/title&gt;-------------显示页面标题&lt;/head&gt;&lt;body&gt;-------------------------body标签里一般放可视化标签，显示在页面中的内容都放在body标签中&lt;h1&gt;标题&lt;/h1&gt;----------------&lt;h1&gt;标签：是最大号的标题标签还有&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt; &lt;p&gt;内容&lt;/p&gt;-----------------&lt;p&gt;标签：是段落标签，用来包裹一个段落的文字&lt;/body&gt;&lt;/html&gt;XHTMLXHTML 指可扩展超文本标签语言（EXtensible HyperTextMarkup Language）。XHTML 的目标是取代 HTML。XHTML 与 HTML 4.01 几乎是相同的。XHTML 是更严格更纯净的 HTML 版本。XHTML 是作为一种 XML 应用被重新定义的 HTML。XHTML 是一个 W3C 标准HTML标签四个基本的标签标题标签&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt;段落标签&lt;p&gt;&lt;/p&gt;与换行标签&lt;BR /&gt;链接标签&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度&lt;/a&gt;图像标签&lt;img src=&quot;rubbish.jpg&quot; /&gt;1. 标题标签标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt;定义最大的标题。 &lt;h6&gt; 定义最小的标题。2. 段落标签HTML 段落标签段落是通过 &lt;p&gt; 标签定义的。注：浏览器会自动地在段落的前后添加空行。&lt;br&gt;标签可在不产生一个新段落的情况下进行换行3. 链接标签HTML 超链接（链接）标签HTML使用标签 &lt;a&gt;来设置超文本链接。超链接可以是一个字，一个词，或者一组词，也可以是一幅图像您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。在标签&lt;a&gt;中使用了href属性来描述链接的地址。默认情况下，链接将以以下形式出现在浏览器中一个未访问过的链接显示为蓝色字体并带有下划线访问过的链接显示为紫色并带上下划线点击链接时，链接显示为红色并带上下划线语法&lt;a href=&quot;url&quot;&gt;链接的文本&lt;/a&gt;其中href为&lt;a&gt;标签的一个属性，值为目的地地址4. 图像标签HTML 图像标签在 HTML 中，图像由&lt;img&gt;标签定义。&lt;img&gt;是空标签，它只包含属性，并且没有闭合标签。语法&lt;img src=&quot;url&quot; alt=&quot;提示文本&quot;&gt;src属性表示图片源，url 为图像的地址alt属性为图像的描述文本（图片无法正常显示时可以代替图片显示出来）]]></content>
      <categories>
        <category>HTML基础教程</category>
      </categories>
      <tags>
        <tag>HTML基础教程</tag>
        <tag>谈技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F15%2Fhello-world.html</url>
    <content type="text"><![CDATA[第一篇文章咯，换了个博客系统，Hexo在Ubuntu下的安装过程比Windows麻烦多了，但写文的Markdown方式优雅多了。]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
